# 智能合约（整理）


>本文档主要来自书籍《区块链技术指南》邱炜伟，李伟
## 基本概述
智能合约是一套以代码形式定义的承诺，合约参与方节点可以按照合约定义执行对应代码；智能合约拥有确定性、有限性、规范性和不可逆的特点。

智能合约的运行环境是合约执行引擎。合约执行引擎满足两个条件：执行过程可终止；执行过程结果一致性。从合约执行引擎架构来看，目前典型的设计包括栈式执行引擎、解释型执行引擎和容器化执行引擎三类。
不同执行引擎具有不同设计原理、运行机制和应用。合约执行引擎为合约运行提供了一个封闭的、确定性的沙箱环境，合约在运行时无法请求外界数据，
所以需要使用预言机来搭建合约运行时的封闭环境与外部数据源之间的桥梁。

**智能合约**作为区块链中重要的一部分，其核心功能是让用户能够定义一系列针对账本操作的逻辑，合约执行引擎为其提供了丰富的数据类型和工具方法，让开发者能够灵活多样地对账本数据进行操作。

**智能合约**的生命周期包括部署、调用、升级、冻结、解冻和销毁等阶段。合约所有者可以对合约的生命周期进行管理。

### 1. 合约的定义
智能合约最早由美国计算机科学家Nick Szabo于1994年提出，他在1998年发明了一种名叫**Bit Gold**的货币，该货币发行时间早于比特币10年。
Szabo将智能合约定义为执行智能合约的计算机化交易协议，他想把电子交易方法的功能扩展到数字领域。区块链智能合约支持创建无需信任关系的协议，
这代表智能合约参与节点可以通过合约作出可被无条件信任的承诺，从而消除公众对公证机构的需求，降低信任成本。

对于区块链中的智能合约来说，合约是一段计算机逻辑代码，其中包含了区块链用户之间的协议条款，之后这段代码将写入区块链网络。当智能合约参与节点发起对合约的调用交易时，
合约逻辑会被执行引擎执行，最终保存智能合约执行产生的数据和结果，并生成一条可追溯且不可逆的交易记录。

### 2. 智能合约特性
智能合约拥有确定性、有限性、规范性和不可逆的特点。这些特性保证了合约在区块链网络中的执行是安全且被用户认可的。

#### 2.1 确定性
确定性指的是执行结果确定，在输入相同的情况下输出一定相同，这也是编程语言中常见的函数所拥有的特性之一。执行结果包括合约执行逻辑、对账本的修改和结果返回值。
确定性保证运行在不同区块链节点上的同个智能合约的执行结果一致。若不一致会导致节点无法就执行结果形成共识。
>注意，不考虑合约中引用的状态数据对执行结果的影响。

在编写智能合约时应该**禁止调用**可能导致合约产生非确定性结果的数据源，或者是定义某些可能导致合约非确定性的逻辑。不稳定数据源有很多，例如当前时间戳、生成随机数以及请求外部数据等。
不稳定逻辑如并发程序等。

#### 2.2 有限性
有限性指的是一次合约执行占用的资源有限，包括时间和空间资源。智能合约在设计时就应该考虑其执行过程中对资源占用情况的计算，具体限制占用资源的措施在不同的合约执行引擎上不同。
例如，以太坊采用gas计费的方式，对合约执行的每条指令和申请的存储空间都进行定量计费，合约所有者可以设定消耗gas的上限，但仍需为已消耗的资源付费。
Fabric使用容器化的执行引擎模拟交易执行，将空间资源从区块链节点上剥离出去，通过限制执行时间来对其进行限定。

如果某次合约执行过程占用了大量资源，那么节点系统资源将被大量消耗，从而导致系统性能下降，甚至整个区块链网络进入停滞状态。

#### 2.3 规范性
规范性即智能合约编写规范，规范编写合约才能满足执行引擎的执行条件，并且减少合约漏洞。

在**The DAO**事件发生后，合约规范性和安全性得到了重视。最著名的规范性检查当属ERC20接口标准检查。ERC20是以太坊智能合约的标准接口说明，
如果合约开发者没有按照这个标准编写合约，那将对DApp带来不可估量的损失。例如，开发者在使用transfer函数时未声明返回值，可能导致合约无法完成正常交易和转账，
所以开发者需要在实现转账操作的同时，增加目的地址非零检查等。 

### 3. 智能合约架构
区块链智能合约架构一般包含共识、执行和存储模块。共识模块将交易定序后发送给执行模块，存储模块则保存智能合约执行产生后的账本数据和区块数据；
执行模块不仅需要串联共识模块和存储模块，还需要负责合约的执行。通常来说，执行模块包含智能合约执行引擎，为智能合约提供上下文环境和账本数据读写支持。
下图展示了智能合约执行架构

<img src="./images/smart_contract_arch.jpg" width="700">

智能合约需要先部署到区块链以太坊上，将智能合约和某个账户地址进行绑定，后续对该合约的数据改动都将保存到账本中对应的地址下。
区块链用户可以通过区块链平台的SDK发起合约交易，指定要调用的合约地址和合约方法参数，经过SDK编码后将交易发送给区块链平台。节点收到交易后通过共识模块对其进行定序和广播，
之后交由合约执行引擎进行交易验证。执行引擎为合约执行构造了执行的上下文环境，提供了合约执行的参数和账本访问的接口；同时能够让合约管理者对合约的生命周期进行管理。
合约执行完成后的执行结果将会写入账本，在区块提交后，用户可通过SDK查询合约执行结果，智能合约执行结果主要包括合约方法的返回值，可能还包括合约执行消耗的gas、交易哈希值等。

上面描述了一种常见的智能合约架构工作模式，不同区块链平台在具体实现上有所出入。例如，合约执行引擎可以有多重不同架构，支持不同合约语言。
不同架构的执行引擎和账本的交互也有所不同。例如，EVM和HVM是两种支持不同合约语言的执行引擎。它们对于指令的定义也是不同的；同样地，合约执行模块也并非要包含合约执行引擎。
例如，Fabric将合约执行引擎独立为背书节点（Endorser），执行模块只对执行结果的读写集进行冲突检查与合并。
>HVM是趣链区块链平台上以Java为合约语言的执行引擎。

### 4. 智能合约生命周期管理
#### 4.1 生命周期概述
智能合约生命周期是从一个智能合约被创建开始，直至该智能合约被销毁结束。在智能合约存活的生命周期期间，合约管理者可以对合约进行升级、冻结、解冻等操作。

#### 4.2 生命周期管理
在智能合约被部署后，一般只有合约所有者才能管理其生命周期。对合约生命周期的不同管理操作，会对区块链节点产生对应的变更，最终体现在世界状态中，
包括但不限于部署、调用、升级、冻结、解冻销毁等。

**【一、部署】**  
部署合约就是创建一个合约账户，以及将合约保存到区块链账本的合约账户中的一个过程。合约上链后，才可以被用户使用或被其他合约调用。

**【二、调用】**  
调用者角度的不同，可以将调用分为以下2种。
1. 调用已部署的合约：本质上是调用部署在链上的合约的某个函数。
2. 跨合约调用：从一个合约中调用另一个合约的某个功能，这要求被调用合约是正常状态。

**【三、升级】**  
升级合约就是在某个特定合约地址上，用新的合约替换旧的合约。替换时要求被替换合约是正常状态。升级过程中也要注意一些问题。开发者在升级合约时需要遵循一定的升级规范，
确保旧的合约数据在新的合约中仍然能被访问到。

**【四、冻结】**  
合约被冻结后会被禁止调用或升级。

**【五、解冻】**  
冻结的合约在被解冻后恢复正常状态，可以被调用或升级。

**【六、销毁】**  
销毁即删除合约。销毁后，用户不能调用合约方法，也无法访问在账本中记录的合约状态数据，该行为只有合约管理者能够触发。

## 典型的智能合约执行引擎
智能合约执行引擎作为合约的运行环境，其主要职责是准确地运行用户编写的智能合约逻辑，一般智能合约执行引擎需要满足以下两个条件。
1. 执行过程可终止。合约不能无限占用执行引擎资源而不释放，一般会通过合约中执行的指令进行计费，或者限制合约执行时间。
2. 安全执行环境。保证合约执行不会导致程序崩溃，屏蔽执行过程中的随机因素，保证相同的输入会有相同的输出。

合约执行引擎还为合约执行提供上下文环境，包括账本数据的访问、外部数据的获取，最终将执行结果交由区块链共识模块进行全网一致性验证。从合约执行引擎的架构来看，
目前典型的合约执行引擎主要包括栈式执行引擎、解释型执行引擎和容器化执行引擎三类，不同架构的执行引擎有各自的优缺点，下面将分析不同执行引擎的设计原理、运行机制和典型应用。

### 1. 栈式执行引擎 
#### 1.1 设计原理
这类引擎通过栈式数据结构来执行合约。栈式执行引擎通常先将合约编译成字节码指令的形式，而字节码指令记录的就是针对栈数据的操作，配合程序计数器，
通过不断地操作数据入栈和出栈，最终执行完合约方法逻辑并返回结果。部分栈式执行引擎还会引入局部变量表和栈帧的概念，其目的也是辅助字节码指令的栈式执行过程。
局部变量表是一个能暂时存储数据的列表，可以保存智能合约方法参数或栈数据计算的中间结果；栈帧主要用于保存智能合约方法调用的调用栈信息和当前执行智能合约方法的上下文环境，
当然这两个结构不是必需的，单纯使用栈数据也能实现对应功能。

#### 1.2 运行机制
下面通过一段伪代码来解释字节码指令的运行过程。
```
func int add(int a, int b){
    int c = a + b;
    return c;
}
```
同时我们定义一系列字节码指令并规定其行为，如下表所示。

| 指令      | 行为                           |
|---------|------------------------------|
| load x  | 表示将局部变量表第x个位置元素加载到栈顶         |
| add     | 表示将栈顶的两个元素出栈，并进行加法运算，结果再压入栈顶 |
| store x | 表示将栈顶元素出栈，存入第x个位置的局部变量表      |
| return  | 表示将栈顶元素出栈，并作为智能合约方法返回值返回     |

根据上表中的指令定义，我们可以得出上文伪代码经过编译后最终表现为如下指令行为。
```
// 假定入参为1，2，那么add(1,2)的过程如下
load 1
load 2
add
store 3
load 3
return
```
栈式执行引擎通过程序计数器记录当前正在执行的指令，最终根据合约编译后的指令作出相应指令操作。当然，不同栈式执行引擎会有不同的栈式结构和指令定义，
但是基本原理与上述执行过程相同。

栈式调用在智能合约停机和安全控制方面比较容易，可通过指令执行次数和指令对应权值计算出合约执行复杂度，定量控制合约的执行时间，从而保证不同执行环境下执行相同的合约的复杂度一致；
而安全方面则可以通过禁用系统指令和方法的形式来控制，包括去除可能造成随机因素的调用，从而保证执行结果的一致性。

#### 1.3 典型应用
**【一、EVM】**  
Solidity是一门图灵完备的智能合约原因，需要被编译器编译成字节码指令，运行在EVM（以太坊虚拟机）上。Solidity和EVM的出现，使得编写智能合约变得十分容易，
让很多基于区块链的DApp大放光彩，推动了区块链智能合约的发展。Solidity通过solc编译器可以编译输出两种格式的文件：bin和abi。bin文件为合约的字节码文件，
用户将合约对应的bin文件部署到区块链上，通过abi文件编码参数进行合约的调用。EVM执行引擎会解析出用户调用的合约方法，逐条执行bin文件中的指令，执行过程基于一个操作数栈进行，
同时在EVM中采用一个Memory结构来存储操作数栈执行过程的中间执行结果，即上文描述中的局部变量表的作用。

Solidity从设计初期就作为智能合约语言来考虑，其在账本操作上有较大优势。合约中需要进行的账本操作可以在编译期翻译为账本操作指令`SSTORE`和`SLOAD`，
分别为存储和读取账本数据。在EVM中的最小slot（数据槽，用来存储数据的字节组合）为32字节。因此，对于Solidity中的静态类型，如int、uint和byte32等，
其最多只会占用一个slot，获取完整数据只需进行一次指令操作；而对于动态类型，如String、bytes和map等，其会将数据进行拆分，并依据数据大小建立索引，
一次完整的数据读取涉及多次账本操作，需要从多个slot中恢复原始数据。

**【二、WASM】**  
WASM（WebAssembly）是一种新的字节码格式，最初是为了解决JavaScript在浏览器上复制逻辑执行效率低的问题，主要是一些CPU密集型的工作，如需要在web前端进行的游戏逻辑和图像处理任务。

WASM字节码简短高效，使得主流语言C/C++、Rust和Go开始支持编译为WASM字节码格式。WASM的这些优势也受到了区块链项目的青睐，拓展了区块链使用高效多智能合约语言的可能性。
WASM执行引擎本质上还是一个栈式虚拟机，典型实现包括操作数栈、局部变量表和程序计数器。

由于WASM不像Solidity一样能够通过编译器增加账本访问指令，以支持对区块链账本的访问，所以为了能够将WASM和区块链系统整合起来，需要为WASM编写的合约提供能访问区块链网络的账本数据接口。
WASM字节码提供导入模块功能，通过自定义账本访问模块，使用native方式实现模块内容，从而将账本接口和WASM执行引擎结合起来。在合约中引入账本访问模块后即可操作账本数据，
具体账本模块接口的定义形式可以根据不同的区块链平台进行修改，具有较大灵活性。

**【三、HVM】**  
HVM（HyperVM）是基于趣链区块链平台开发的合约执行引擎，其实现基于《Java虚拟机标准规范》开发的JVM执行引擎，能够运行用Java编写的合约。
Java合约在经过javac编译后会形成class字节码文件，每个Java类文件都将被编译成一个class文件，多个class文件经过压缩可形成合约jar包，然后将jar包部署到趣链区块链平台之上。

HVM和WASM执行引擎面临一样的问题，需要能够让Java编写的智能合约访问区块链账本，依赖Java提供的native方法机制（JNI接口），HVM可以将部分Java的合约方法通过JVM虚拟机底层实现，
而不是通过JDK实现。通过native实现的JVM虚拟机底层实现方法，实现封装对区块链账本访问的接口。进一步地，HVM为了让合约编写者能够更方便地访问区块链账本，
将账本操作封装成HyperTable、HyperMap和HyperList结构，使合约中对于账本的访问方式如同访问Java的集合类型。

### 2. 解释型执行引擎
#### 2.1 设计原理
基于解释型执行引擎的合约的最大特点是，每笔交易都包括一个执行脚本，执行脚本内指定了当前交易的账户对象和对应的操作逻辑，而不是在交易结构中指定交易的账户对象。

一笔交易的交易脚本每次都可以被修改，并且可以在脚本中操作多个账户对象。执行引擎将根据脚本定义的逻辑执行。交易脚本大大增加了交易执行的灵活性，可以为每笔交易自由制定逻辑。

#### 2.2 运行机制
在按照区块链平台要求编写对应的交易脚本后，将其作为payload，由交易发送方对自定义的交易脚本进行签名，发送至区块链平台。最终由执行引擎根据脚本中的逻辑进行交易验证。

#### 2.3 典型应用
Move语言是Facebook公司的区块链平台Libra上定义的交易脚本语言，旨在为Libra区块链提供安全可编程的基础。Libra区块链中的账户是一个容器，
它包含任意数量的Move资源和Move模块（Modules）。提交到Libra区块链的智能合约执行交易包含用Move语言编写的交易脚本，脚本可以调用模块声明的过程来更新区块链的全局状态。

Move模块相当于是传统区块链上的智能合约，在Move模块下可以自定义资源，一个账户可以有多个Move模块，Move虚拟机通过字节码验证器保证Move资源的安全性。
用户编写Move模块后将其编译，再通过交易的形式将其发布到区块链账户地址上。交易脚本可以调用Move模块中声明的公开过程。

执行脚本之前，执行引擎将对Move交易脚本进行反序列化，解析为Move虚拟机的字节码。Move虚拟机通过操作数栈来完成Move交易脚本字节码中定义的数据操作，
使用CallStack来记录交易脚本的方法调用过程，同时通过计算执行指令的Gas定量计算智能合约的复杂度，用户需要为Move交易脚本的执行过程付费。

### 3. 容器化执行引擎
#### 3.1 设计原理
容器化执行引擎最大的特点是逻辑和数据隔离，其实现相对比较简单，不需要实现虚拟机来执行智能合约逻辑，取而代之使用容器作为智能合约执行环境。
该引擎会提供一个安全的沙箱环境作为容器来运行智能合约，不同的智能合约只需提供不同的容器和对应语言的账本操作API。由于整个过程在容器中运行，
因此执行过程不会影响到区块链网络，用户只需收集在容器中执行的模拟操作账本读写集。

#### 3.2 运行机制
执行引擎接收客户端发送的合约执行请求，通过容器化环境将合约放入容器，通过对应语言的账本操作API在容器中访问账本，此时一般不会将智能合约执行结果直接写入账本，
而是执行模拟操作账本的读写集后将结果返回给客户端，客户端需要再次发起将模拟交易产生的读写集写入账本的请求。

由于容器化执行引擎执行合约逻辑一般native化，所以不能采用定量分析合约复杂度的形式，而是采用超时机制来限制合约复杂度。

#### 3.3 典型应用
典型应用代表是Fabric 链码（Chaincode）。Fabric执行引擎核心组成主要包括SDK、排序节点、背书节点（Endorser）、容器化执行引擎和账本。执行过程大致如下步骤。
1. 生成提案。由客户端生成一个提案，提案指的是一个调用智能合约功能函数的请求，用来确定哪些数据可以读取或写入账本（一般客户端会借助目前Fabric提供的一系列SDK生成提案），
2. 背书节点模拟执行。提案被发送至背书节点进行模拟执行并背书，背书节点会进行响应的校验，然后再将提案交由对应的链码进行模拟执行，之后背书节点会对执行结果进行背书，将背书的提案response返回给客户端。
3. 客户端封装交易。客户端收集符合背书策略的提案response，将其封装为一个交易，调用排序节点的Broadcast接口，发送交易至排序节点进行交易排序。
4. 提交节点进行交易校验。排序节点将交易排序后通过主节点将交易转发给其他节点，最终每个提交节点在收到交易后都会对交易进行校验，包括签名、背书策略及链码模拟执行产生的读写集的校验。
在校验无误的情况下将结果提交到账本，同时更新世界状态。

**Fabric容器化执行引擎的缺点**  
- 虽然能做到逻辑和账本隔离，并且支持多智能合约语言，但是其缺点也是很明显的。首先，由于容器化执行导致合约逻辑的复杂度不能定量控制，而是依赖超时机制，
因此很有可能导致多个背书节点的容器化执行引擎受到系统环境的影响，出现部分背书节点超时、部署背书节点不超时的情况；
- 其次，采用Fabric链码模拟执行产生读写集，读过读写集冲突校验判断，抛弃产生冲突的交易，可能导致用户执行的智能合约结果最终无法生效；
- 最后，对于客户端来说，需要收集多个背书节点的提案response才能构成交易，导致客户端与服务器端交互逻辑复杂，使用体验不够优化。

## 智能合约与去中心化应用
### 1. DApp
#### 1.1 DApp概述
DApp全称是Decentralized Application，即去中心化应用。  
区别于传统App，DApp依赖的是区块链基础设施作为运行平台，所以天然具备不可篡改、去中心化存储的特性。DApp最大优势是去中心化、完全开源、自由运行。但是，凡事都有两面性，优势在某些时候也成为劣势，
黑客可以随时获取DApp的源码进行漏洞分析，这就大大增加了DApp遭受攻击的风险。同时，自由运行的特点在一定程度上提高了监管、审查的难度，还有其他许多问题。

DApp并无法取代传统App，二者是和谐共存的关系。因为它们各自存在于不同的场景，发挥其各自的优势。共同促进互联网繁荣的并存关系。

区块链开发者要把握好DApp的优势，解决App无法解决的市场与技术矛盾。目前，市场高热度的DApp主要由去中心化交易所（Exchange）、游戏等与交易数据、交易资产有直接关联的应用。

#### 1.2 DApp应用
TODO


参考
- [《区块链技术指南》邱炜伟，李伟](https://item.jd.com/10057248453271.html)