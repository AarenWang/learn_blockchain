# 共识算法

共识算法是各类分布式系统（如分布式文件系统、分布式DB）中保证系统状态一致性的重要技术。根据需求不同，在不同场景使用的共识算法也不同，如公链和联盟链
对共识算法的要求不同，所使用的算法也不同。

公链要求共识算法具有高扩展性，能够在节点动态传入网络的情况下保证共识流程的节奏，同时又要防止拜占庭节点对网络的攻击。受限于FLP定理和CAP定理，公链使用的
共识算法一般不能保证强一致性；而联盟链则需要强一致性、高性能，但对高扩展性和防止拜占庭节点攻击方面的要求没有公链那么高。

## 背景

### 1. 共识算法简史
- 1978年Jim Gray在论文中国提出两阶段提交（2PC），首次尝试解决分布式数据中的一致性问题，该方案存在已验证的阻塞和脑裂问题；
- 1981年Dale Skeen在论文中提出三阶段提交（3PC），可以解决2PC的阻塞问题，但是依然存在脑裂和单点故障问题；
- 1982年Leslie Lamport在论文中提出了著名的拜占庭将军问题，引入了拜占庭错误，将一致性问题的复杂度又提升了一个档次，并在论文中给出了在同步模型下的两种解法；
- 1985年，F、L、P（姓名简写）三人在论文中提出了FLP不可能定理，直截了当的告诉人们**在异步网络中，只要由一个节点故障，就不可能存在一种完美的共识算法**；
- 1988年，Dwork、Lynch、Stockmeyer在论文中提出了部分同步模型，是一种介于同步和异步网络之间的网络模型，该模型中，FLP定理的限制可以被打破，即当
  系统处于异步状态时，共识可以阻塞，但系统总会在一个时间后进入同步状态，此时就可以继续达成共识；
- 1990年，Lamport在论文中提出Paxos，这是首次被提出的一个能在异步网络中保证安全性，并在进入同步网络后保证共识性的共识算法。在这之后的一大部分共识
  算法都是Paxos的变体，如Raft。但是，Paxos的最大问题在于它只能安全运行在非拜占庭网络中，一旦有恶意节点加入网络，那么整个系统将崩溃；
- 1999年，Muguel Csatro和Barbara Liskov在论文中提出了PBFT共识算法，该算法大大降低了拜占庭容错算法的网络复杂度，成为第一个实用的拜占庭容错算法；
- 2008年，中本聪发表了比特币白皮书，首次提出比特币概念，同时将PoW共识算法应用到区块链中。此后，各类证明类的共识算法相继出现，如PoS、PoA等，共识算法
  也从传统分布式一致性算法慢慢演化成独特的区块链共识算法。


### 2. 早期数据库系统中的共识机制（分布式一致性方案）

#### 2.1 两阶段提交
在数据库系统中，两阶段提交是一个普遍使用的保证一致性的方法。它是由一个协调节点作为中央控制节点。

**第一阶段**  
协调节点向询问所有节点「是否准备好」，等待各节点响应

**第二阶段**  
若各节点响应都是OK，则协调节点向所有节点广播**Commit**指令，只要有一个说不就是**Rollback**指令。

**缺陷**  
- 阻塞：第一阶段中，在收到所有节点回复前，系统所有节点（协调者和已回复的节点）保持阻塞状态，协调者会锁定资源；
- 脑裂（数据不一致）：第二阶段中，部分节点因为网络问题未收到协调者的指令，也就不会执行对应指令，则系统产生不一致性；
- 单点故障：过程中，协调者是单节点。

#### 2.2 三阶段提交
为了解决两阶段提交问题，三阶段提交出现了。与前者的不同之处在于，在正式提交前，协调节点会再发送一次「准备提交」的消息，当收到所有节点的OK回复后，
协调节点再广播**Commit**指令。需要注意的是，在最后提交阶段，若其他节点没有收到协调者的提交指令，等待超时后仍然会执行提交（避免参与者一直阻塞）。  
它只解决了两阶段提交中的阻塞问题，但是脑裂和单点故障仍然未解决。因此，无论两阶段提交或三阶段提交，都不能作为一个分布式共识算法，只能在通常情况下
保障分布式系统的一致性。

#### 2.3 小结
两阶段和三阶段提交一般用在同步通信的分布式系统中，而多数分布式系统是由多个主机通过异步通信的方式组成集群。 在异步系统中，可能出现无法通信的故障主机，
主机可能性能不够，网络可能拥塞，都会导致错误信息再系统内传播。因此，需要更健壮的共识算法在默认不可靠的异步网络中建立容错协议，以确保各主机达成安全
可靠的状态共识。

### 3. 拜占庭将军问题
这个问题是一个设计健壮的共识算法需要解决的一个核心问题，学习共识算法需要先理解它。  

拜占庭将军问题，是在1982年Leslie Lamport、Robert Shostak、Marshall Pease三位科学家的论文中提出的。下面贴出论文中的描述(来自维基百科)：
>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为**进攻或撤离**两种。因为部分军队进攻部分军队撤离可能会造成
> 灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。
> 在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道
> 共同的投票结果而决定行动策略。

系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。假设有9位将军投票，其中1名叛徒。8名忠诚的将军中
出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的
将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。如下图

<img src="./images/baizhanting_problem.jpg" height="350" width="500">

除了叛徒，还可能存在以下问题：
- 叛徒伪造其他将军身份投票
- 即使保证所有将军忠诚，也不能排除信使被敌人截杀或被间谍替换

因此很难通过保证人员可靠性及通讯可靠性来解决问题，只能通过收到的投票情况来做决定。

**问题建模**  
对拜占庭问题进行建模后，得出这样的问题描述：在上述假设下，能否找到一种算法，能够满足以下两个条件：  
- A. 所有忠诚将军最终会同意相同的决策；
- B. 少数叛徒不会导致忠诚将军们选择错误的决策。

满足这两个条件，就可以说是解决了拜占庭将军问题！三位科学家在论文中也给出了两种解法：
- **基于口头消息的协议**
- **基于书面消息的协议**

**解法1：基于口头消息的协议**  
这个方案中，需要有至少3m+1个将军才能容忍m个叛徒的存在。首先定义「口头消息」协议能正确进行的三个前提：
- A1：每个发出去的消息都能被成功地传递（通信正常）；
- A2：消息接收方能准确知道发送方是谁（不能伪造消息）；
- A3：消息丢失可以被检测到（消息丢失可以重发）；

可以看出，上述三点定义了一个严格的同步网络。这个协议还要求所有将军之间可以直接发生消息（点对点通信）。关于算法证明过程这里不做详述，请自行查阅权威
资料。下面通过例子来简单理解其思想：
1. 当共有n=3个将军时，若有m=1个叛徒时，则问题无解。设有ABC三位将军，有三种情况如下：
   - 最坏（最简单）：A是叛徒，假如A是指令发出者，向BC发出撤退指令（错误指令），然后B肯定向C传达相同撤退指令，那么BC最后都会作出错误的决策，也就是撤退（本来是进攻）；
   - 一般1：A是叛徒，也是指令发出者，向BC发出不同指令，然后BC之间会互相传达指令，结果是BC收到不同指令，无法作出最终决策；
   - 一般2：A是叛徒，但A是指令传达者，B是指令发出者向AC发出攻击指令（正确指令），然后A向C传达撤退指令（错误指令），结果是C收到不同指令，无法作出最终决策。
2. 当共有n=4个将军时，如果其中有m=1个叛徒，则问题可解，设有ABCD四位将军，有四种情况如下：
   - 最坏（最简单）：A是叛徒，也是指令发出者，向BCD发出错误指令X，同上，BCD最后作出错误决策；
   - 一般1：A是叛徒，也是指令发出者，向B发出正确指令X，向CD发出错误指令Y，然后BCD之间互相传达指令，结果是BCD都作出错误决策Y；
   - 一般2：A是叛徒，也是指令发出者，向BCD各自发出不同指令XYZ，然后BCD之间互相传达指令，结果是BCD都收到不同指令，无法作出最终决策；
   - 一般3：A是叛徒，但A是指令传达者，由B发出正确指令X给ACD，然后A会传达错误指令Y给CD，CD之间再互相传达，结果是CD都收到2个X和1个Y，
   由此可以判断A是叛徒，CD能够作出正确决策；

**解法2：基于书面消息的协议**  
这个方案可以处理n个将军至多有m个叛徒的情况，其中n≥m。  
根据基于口头协议的方案介绍，可以发现它不能容忍消息伪造，因为一旦叛徒能够伪造其他将军的消息，且接收方不能鉴别，那么根据最坏假设原则，接收方可以认为
所有收到的消息都是伪造的，那么所有将军都不能作出最终决策，只能撤退。而「基于书面消息的协议」的解法正是解决了这一关键问题，它引入了签名特点，消息
带上将军签名，接收方可以验证签名，从而使消息变得不可伪造。对应到计算机网络中，所有网络消息都带上节点的私钥签名，其他节点使用公钥验证。  


**拜占庭容错（BFT）**  
如果说有人能制定一个方案，能让将军们仅根据收到的投票情况就能决定它们的战略，就可以称作实现了**拜占庭容错**！
>拜占庭错误算是分布式系统中一个最极端的问题，某个算法解决了这个问题，就可以说这个共识算法是足够健壮的。


### 4. 共识系统的基本定义
#### 4.1 关于拜占庭缺陷和故障的4个定义
1. 拜占庭缺陷：任何观察者从不同角度看，均表现出不同症状的缺陷；
2. 拜占庭故障：在需要共识的系统中，由于拜占庭缺陷导致丧失系统服务；
3. 宕机缺陷：在需要共识的系统中，导致进程停止运行发生的缺陷，该缺陷对系统不产生其他副作用；
4. 宕机恢复故障：在需要共识的系统中，导致进程停止运行发生的故障，故障在重启进程后恢复，对系统不产生其他副作用；

在分布式系统中，不是所有缺陷或故障都能称作拜占庭缺陷或故障。像宕机、丢消息等缺陷或故障都不算。拜占庭缺陷或故障是最严重缺陷或故障，具有不可预测和任意性
的特点，例如遭黑客破坏、中木马病毒的服务器就是一个拜占庭故障例子。

在一个由N个节点组成的分布式系统中，一个正确的共识算法必须满足如下三个特性：
- 一致性：所有节点都同意某个决策值
- 有效性（正确性）：该决策值必须由这N个节点中的某个节点提出
- 终止性（可结束性）：所有节点最终都能完成决策（最终都能确定一个正常状态）

通常把满足一致性和正确性称为安全性，而满足可结束性称为活性。

一致性好理解，如果所有节点最终决策值不一致，就无法共识。在某些情况下，可以减弱这个条件：只要多数节点共识就可以认为系统达成共识。  
有效性这样理解，如果最终决策值始终是一个默认值，那其实是没有意义的。例如在数据库提交时，若每次决策都是「回滚」，虽然不会破坏一致性，但所有合法事务
都会回滚，这显然是不合理的。  
终止性也是一个重要的特性。一致性定了如何选择一个决策值，却没有定义何时进行这样的选择。因此，共识算法需要终止性来保证系统不停向前运转。而不是一直
停留在一个决策中无法结束。这样的共识算法是不实用的。

### 5. 通信模型
分布式系统建立在许多通过网络或其他方式进行通信的节点之上，通信机制的不确定性会限制共识算法的设计。通信模型定义了不同消息的延迟对于分布式系统的限制
能力。总的来说，存在三种类型的通信模型：同步、异步、部分同步模型。

#### 5.1 同步模型
同步模型中，节点之间的通信延迟存在一个已知上限，超过上限则认为对方节点故障。这是一个非常理想的通信模型，早期的分布式一致性算法都在此模型假设下设计的。

#### 5.2 异步模型
异步模型中，没有通信延迟上限，可以包含任何异常情况，如通道问题、节点本身问题等。相比同步模型，异步模型更为符合现实情况，也就更通用。一个适用于
异步模型的共识算法，也必然适用于同步模型，但反之不成立。
>在异步模型中设计一个完美的共识算法被证明是**不可能**的！

#### 5.3 部分同步模型
介于同步和异步模型之间。于1988年在某论文中提出。模型假设一个全局稳定时间GST，在GST之前，系统可以处于异步状态，但在GST之后，系统可以恢复到同步状态。
然而该模型中的GST是未知的，也就不知道什么时候达到同步状态。这个模型同样贴合现实世界中对共识算法的需求，即共识总可以在同步状态下达成，当出现网络
问题时，共识会出现一段时间的阻塞，直到网络正常。因此，这个模型中的共识算法设计首要保证的是系统进入异步状态时的安全性（可以阻塞，但不要产生错误共识），然后在
进入同步状态后产生正确共识。  
这个模型是许多共识算法的模型基础，如Paxos、ViewStamp Replication、PBFT。

### 6. FLP定理
1985年，Fischer、Lynch和Patterson三位科学家发表了论文，提出了著名的FLP定理，它是分布式系统领域的最重要定理之一。该定理给出了一个重要的结论：
>FLP定理：在一个异步通信网络中，只要存在一个故障节点，就不存在一种完美的共识算法可以正确地终止（使所有节点达成一致）。

FLP定理是在一个比异步通信更强的通信模型下得出的结论，如果在这样一个更强的通信模型下都无法保证共识算法的终止性，那么在现实中更弱的通信模型下也不可能
达到这种保证。  
该定理假设系统中不存在拜占庭错误，并且消息传递是可靠的，即消息传递延迟未知，但最终都会成功传递且只传递一次。也就是说FLP定理假设网络消息可能出现延迟，
但是不会出现丢包、重复包的情况，这是一个比现实网络更可靠的网络假设条件。但即便是在这种网络假设下，FLP定理也证明了在任意时间停止某个节点/进程，会导致
任何一个共识算法都无法达成最终一致，更不要说现实网络中还存在网络分区与拜占庭错误等问题了。（网络分区指的是在系统中由于部分节点网络不通导致整个系统
被划分为不同的区域的现象）  
因此，如果不对通信模型做进一步的假设，或者对容错类型做更大的限制，那么该问题就不存在一个完美的解决方案。  
FLP定理告诉人们，不用再想方设法地设计一个在异步网络中始终能够达成一致的共识算法。因此，后续的共识算法设计通常会在某些方面作出妥协。例如，网络假设不再是
异步模型而是部分同步模型，即允许存在一定时间的异步网络状态，在此期间无需达成共识，但只要等到网络恢复到同步状态，就可以立即达成共识。虽然这样对系统活性
有一定的影响，但是只要能够保证系统安全性，依然是一个可接受的共识算法。例如，Paxos理论上也会出现活锁，但其能够保证即使出现活锁整个算法也是安全的，那么在
实际场景中，只要活锁结束了，就可以继续推进共识了。
>FLP定理在论文中有其完整证明过程，非数学专业不易看懂，感兴趣者请自行查阅资料。

所以目前已知的共识算法都会采用下面的部分假设：
- 故障模型：非拜占庭故障/拜占庭故障；
- 通信类型：同步/异步；
- 通信网络连接：节点间直连数；
- 信息发送者身份：实名/匿名；
- 通信通道稳定性：可靠/不可靠；
- 消息认证性：认证消息/非认证消息；

### 7. CAP定理
2000年，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出了CAP猜想。两年后，MIT的Seth Gilbert和Nancy Lynch从理论上证明的CAP猜想。
此后，CAP理论成为分布式领域公认定理。CAP定理认为一个分布式系统中最多只能同时满足以下三种特性中的两种：
- 强一致性（Consistency）：即当系统中任意节点完成了一次写操作后，那么其他任意节点读取出来的结果必须是最新结果，或者返回错误。这是最高级别的一致性，它的
实现代价通常非常之大，所以在工程实践中，通常放宽至较弱的一致性，如最终一致性。
- 可用性（Availability）：指来自客户端的请求在一定时间内必须收到正确回应，即服务一直可用。
- 分区容错性（Partition tolerance）：指当系统出现了网络分区问题时，系统仍然能够对外提供服务。

CAP定理告诉人们，在设计分布式系统时，不必奢求同时满足上述三种特性，必须选择性地做出取舍，才能设计出一个实际可用的、高效的系统。在分布式网络环境中，
由于网络分区是常态，因此一般在一致性和可用性上做权衡，如AWS推出的分布式数据库Dynamo就是舍弃了一致性的例子，而谷歌的GFS则舍弃了可用性。

## 共识算法分类
从传统分布式一致性算法逐渐发展到现在区块链共识算法的百花齐放，共识算法的发展已经走过四十个年头。不同共识算法侧重点不同，它们面临的问题、环境也不同。
下面从几个角度对共识算法进行分类。

**容错类型**  
根据是否解决拜占庭错误分类：
1. 拜占庭容错共识算法：PBFT、PoW、PoS、DPoS
2. 非拜占庭容错共识算法：Paxos、Raft

通常来说，在公链环境下必须使用拜占庭容错算法，在联盟链中可以根据参与方之间的信任程度进行选择。

**算法确定性**  
1. 确定性共识算法：Paxos、Raft、PBFT
2. 概率性共识算法：PoW、部分PoS

确定性共识指共识决策一旦达成，就不存在回退可能性。这类共识算法通常是传统分布式一致性算法及其改进版本；概率性共识是指已经达成的共识在未来一定概率
回退，这个概率随着时间的推移会趋近于0，这类共识算法通常应用于公链上。

**选主策略**  
1. 选举类共识算法：Raft、PBFT
2. 证明类共识算法：PoW、PoS

选举类是指通过投票选举出块节点，同一节点可以连续多轮作为出块节点存在。这类共识算法通常是传统分布式一致性算法及其改进版本；证明类是指出块节点需要
通过某种方式证明自己具备某种能力，从而获得出块权，这类算法通常每轮出块节点都不同，从而保证公平性，一般应用于公链。

## 分布式一致性算法
这类算法一般不考虑拜占庭错误，只假设节点宕机、网络故障时，如何让多节点保持一致。比较著名的分布式一致性算法包括：2PC、3PC、Paxos、ViewStamp Replication、
Zab、Raft。

TODO