# 共识算法

共识算法是各类分布式系统（如分布式文件系统、分布式DB）中保证系统状态一致性的重要技术。根据需求不同，在不同场景下使用的共识算法也不同，如公链和联盟链
对共识算法的要求不同，所使用的算法也不同。

公链要求共识算法具有高扩展性，能够在节点动态传入网络的情况下保证共识流程的节奏，同时又要防止拜占庭节点对网络的攻击。受限于FLP定理和CAP定理，公链使用的
共识算法一般不能保证强一致性；而联盟链则需要强一致性、高性能，但对高扩展性和防止拜占庭节点攻击方面的要求没有公链那么高。

## 背景

### 1. 共识算法简史
- 1978年Jim Gray在论文中提出两阶段提交（2PC），首次尝试解决分布式数据中的一致性问题，该方案存在已验证的阻塞和脑裂问题；
- 1981年Dale Skeen在论文中提出三阶段提交（3PC），可以解决2PC的阻塞问题，但是依然存在脑裂和单点故障问题；
- 1982年Leslie Lamport在论文中提出了著名的拜占庭将军问题，引入了拜占庭错误，将一致性问题的复杂度又提升了一个档次，并在论文中给出了在同步模型下的两种解法；
- 1985年，F、L、P（姓名简写）三人在论文中提出了FLP不可能定理，直截了当的告诉人们**在异步网络中，只要有一个节点故障，就不可能存在一种完美的共识算法**；
- 1988年，Dwork、Lynch、Stockmeyer在论文中提出了部分同步模型，是一种介于同步和异步网络之间的网络模型。在该模型中，FLP定理的限制可以被打破，即当
  系统处于异步状态时，共识可以阻塞，但系统总会在一个时间后进入同步状态，此时就可以继续达成共识；
- 1990年，Lamport在论文中提出Paxos，这是首次被提出的一个能在异步网络中保证安全性，并且在进入同步网络后保证共识性的共识算法。在这之后的一大部分共识
  算法都是Paxos的变体，如Raft。但是，Paxos的最大问题在于它只能安全运行在非拜占庭网络中，一旦有恶意节点加入网络，那么整个系统将崩溃；
- 1999年，Muguel Csatro和Barbara Liskov在论文中提出了PBFT共识算法，该算法大大降低了拜占庭容错算法的网络复杂度，成为第一个实用的拜占庭容错算法；
- 2008年，中本聪发表了比特币白皮书，首次提出比特币概念，同时将PoW共识算法应用到区块链中。此后，各类证明类的共识算法相继出现，如PoS、PoA等，共识算法
  也从传统分布式一致性算法慢慢演化成独特的区块链共识算法。


### 2. 早期数据库系统中的共识机制（分布式一致性方案）

#### 2.1 两阶段提交
在数据库系统中，两阶段提交是一个普遍使用的保证事务一致性的方法。它是由一个协调节点作为中央控制节点，协调各参与节点提交会回滚事务。

**第一阶段**  
协调节点向所有节点询问「是否准备好」，等待各节点响应Yes/No。

**第二阶段**  
若各节点响应都是Yes，则协调节点向所有节点广播**Commit**指令，只要有一个回复No就广播**Rollback**指令。

**缺陷**  
- 阻塞：第一阶段中，事务提交过程中，所有节点持有的公共资源都是抢占状态，第三方无法访问（没有超时机制）；
- 脑裂（数据不一致）：
  - 第二阶段中，部分节点因为网络问题未收到协调者的指令，也就不会执行对应指令，则系统产生不一致性；
  - 同样是第二阶段，当协调者和参与节点同时故障时的情况。即先收到提交指令的参与者在完成提交后，且向协调者回复ACK前宕机了，那么即使稍后协调者恢复了，也不知道
  事务的提交状态，必须等待参与者也恢复之后才能确定。
- 单点故障：过程中，协调者是单节点，当协调者故障，系统进入阻塞状态，直到协调者恢复。

#### 2.2 三阶段提交
为了解决两阶段提交的阻塞和脑裂问题，三阶段提交出现了。它引入超时机制和预写机制，以保证节点在宕机恢复后可以从预写日志中恢复正确状态；以及增加一个PreCommit阶段。

**第一阶段：询问提交**  
仍然是协调节点向所有节点询问「是否准备好」，即发出CanCommit指令，等待各节点响应Yes/No，同时开启超时等待，若超时未收到协调者下一步指令则终止事务。

**第二阶段：预提交**  
若所有参与者回复Yes，则协调者再次发出PreCommit指令，允许所有参与者执行预提交，并等待所有参与者回复执行结果Yes/No，同时参与者在回复之后开启超时等待，
若未接收到协调者的下一步指令，**直接提交事务**。
>预提交是指参与者将事务的undo和redo日志写入本地的稳定存储介质，但不进行真正提交；同时这里的参与者超时后回滚是与两阶段提交的「持续等待」的不同之处。

若有参与者回复No或超时回复，则协调者发出回滚指令，所有参与者回滚事务并释放持有的资源（根据undo日志）。

**第三阶段：最终提交**  
若所有参与者再次回复Yes，则协调者发出最后的DoCommit指令，参与者收到后执行最终提交，然后协调者等待参与者回复最后的Ack响应，收到后，完成事务。  
若有参与者回复No或超时回复，则协调者发出回滚指令，所有参与者回滚事务并释放持有的资源（根据undo日志）。

注意，在最后阶段：
1. 协调者宕机时，导致部分参与者未收到DoCommit指令，此时那些参与者在等待协调者指令超时后会直接进行提交；
2. 收到回滚指令后，参与者回滚完成时也需要回复Ack给协调者。

**缺陷**  
它只解决了两阶段提交中的阻塞和单点故障问题（协调者故障后可以重新选举），但是脑裂仍然未解决（出现网络分区后，已收到PreCommit的节点在超时后会提交事务，未收到
PreCommit的节点在超时后会回滚事务）。因此，无论两阶段提交或三阶段提交，都不能作为一个分布式共识算法，只能在通常情况下保障分布式系统的一致性。

#### 2.3 小结
两阶段和三阶段提交一般用在同步通信的分布式系统中，而多数分布式系统是由多个主机通过异步通信的方式组成集群。 在异步系统中，可能出现无法通信的故障主机，
主机可能性能不够，网络可能拥塞，都会导致错误信息再系统内传播。因此，需要更健壮的共识算法在默认不可靠的异步网络中建立容错协议，以确保各主机达成安全可靠的状态共识。

### 3. 拜占庭将军问题
这个问题是一个设计健壮的共识算法需要解决的一个核心问题，学习共识算法需要先理解它。  

拜占庭将军问题，是在1982年Leslie Lamport、Robert Shostak、Marshall Pease三位科学家的论文中提出的。下面贴出论文中的描述(来自维基百科)：
>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为**进攻或撤离**两种。因为部分军队进攻部分军队撤离可能会造成
> 灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。
> 在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道
> 共同的投票结果而决定行动策略。

系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。假设有9位将军投票，其中1名叛徒。8名忠诚的将军中
出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的
将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。如下图

<img src="./images/baizhanting_problem.jpg" height="350" width="500">

除了叛徒，还可能存在以下问题：
- 叛徒伪造其他将军身份投票
- 即使保证所有将军忠诚，也不能排除信使被敌人截杀或被间谍替换

因此很难通过保证人员可靠性及通讯可靠性来解决问题，只能通过收到的投票情况来做决定。

**问题建模**  
对拜占庭问题进行建模后，得出这样的问题描述：在上述假设下，能否找到一种算法，能够满足以下两个条件：  
- A. 所有忠诚将军最终会同意相同的决策；
- B. 少数叛徒不会导致忠诚将军们选择错误的决策。

满足这两个条件，就可以说是解决了拜占庭将军问题！三位科学家在论文中也给出了两种解法：
- **基于口头消息的协议**
- **基于书面消息的协议**

**解法1：基于口头消息的协议**  
这个方案中，需要有至少3m+1个将军才能容忍m个叛徒的存在。首先定义「口头消息」协议能正确进行的三个前提：
- A1：每个发出去的消息都能被成功地传递（通信正常）；
- A2：消息接收方能准确知道发送方是谁（不能伪造消息）；
- A3：消息丢失可以被检测到（消息丢失可以重发）；

可以看出，上述三点定义了一个严格的同步网络。这个协议还要求所有将军之间可以直接发生消息（点对点通信）。关于算法证明过程这里不做详述，请自行查阅权威
资料。下面通过例子来简单理解其思想：
1. 当共有n=3个将军时，若有m=1个叛徒时，则问题无解。设有ABC三位将军，有三种情况如下：
   - 最坏（最简单）：A是叛徒，假如A是指令发出者，向BC发出撤退指令（错误指令），然后B肯定向C传达相同撤退指令，那么BC最后都会作出错误的决策，也就是撤退（本来是进攻）；
   - 一般1：A是叛徒，也是指令发出者，向BC发出不同指令，然后BC之间会互相传达指令，结果是BC收到不同指令，无法作出最终决策；
   - 一般2：A是叛徒，但A是指令传达者，B是指令发出者向AC发出攻击指令（正确指令），然后A向C传达撤退指令（错误指令），结果是C收到不同指令，无法作出最终决策。
2. 当共有n=4个将军时，如果其中有m=1个叛徒，则问题可解，设有ABCD四位将军，有四种情况如下：
   - 最坏（最简单）：A是叛徒，也是指令发出者，向BCD发出错误指令X，同上，BCD最后作出错误决策；
   - 一般1：A是叛徒，也是指令发出者，向B发出正确指令X，向CD发出错误指令Y，然后BCD之间互相传达指令，结果是BCD都作出错误决策Y；
   - 一般2：A是叛徒，也是指令发出者，向BCD各自发出不同指令XYZ，然后BCD之间互相传达指令，结果是BCD都收到不同指令，无法作出最终决策；
   - 一般3：A是叛徒，但A是指令传达者，由B发出正确指令X给ACD，然后A会传达错误指令Y给CD，CD之间再互相传达，结果是CD都收到2个X和1个Y，
   由此可以判断A是叛徒，CD能够作出正确决策；

**解法2：基于书面消息的协议**  
这个方案可以处理n个将军至多有m个叛徒的情况，其中n≥m。  
根据基于口头协议的方案介绍，可以发现它不能容忍消息伪造，因为一旦叛徒能够伪造其他将军的消息，且接收方不能鉴别，那么根据最坏假设原则，接收方可以认为
所有收到的消息都是伪造的，那么所有将军都不能作出最终决策，只能撤退。而「基于书面消息的协议」的解法正是解决了这一关键问题，它引入了签名特点，消息
带上将军签名，接收方可以验证签名，从而使消息变得不可伪造。对应到计算机网络中，所有网络消息都带上节点的私钥签名，其他节点使用公钥验证。  


**拜占庭容错（BFT）**  
如果说有人能制定一个方案，能让将军们仅根据收到的投票情况就能决定它们的战略，就可以称作实现了**拜占庭容错**！
>拜占庭错误算是分布式系统中一个最极端的问题，某个算法解决了这个问题，就可以说这个共识算法是足够健壮的。


### 4. 共识系统的基本定义
#### 4.1 关于拜占庭缺陷和故障的4个定义
1. 拜占庭缺陷：任何观察者从不同角度看，均表现出不同症状的缺陷；
2. 拜占庭故障：在需要共识的系统中，由于拜占庭缺陷导致丧失系统服务；
3. 宕机缺陷：在需要共识的系统中，导致进程停止运行发生的缺陷，该缺陷对系统不产生其他副作用；
4. 宕机恢复故障：在需要共识的系统中，导致进程停止运行发生的故障，故障在重启进程后恢复，对系统不产生其他副作用；

在分布式系统中，不是所有缺陷或故障都能称作拜占庭缺陷或故障。像宕机、丢消息等缺陷或故障都不算。拜占庭缺陷或故障是最严重缺陷或故障，具有不可预测和任意性
的特点，例如遭黑客破坏、中木马病毒的服务器就是一个拜占庭故障例子。

在一个由N个节点组成的分布式系统中，一个正确的共识算法必须满足如下三个特性：
- 一致性：所有节点都同意某个决策值
- 有效性（正确性）：该决策值必须由这N个节点中的某个节点提出
- 终止性（可结束性）：所有节点最终都能完成决策（最终都能确定一个正常状态）

通常把满足一致性和正确性称为**安全性（Safety）**，而满足可结束性称为**活性（Liveness）**。

一致性好理解，如果所有节点最终决策值不一致，就无法共识。在某些情况下，可以减弱这个条件：只要多数节点共识就可以认为系统达成共识。  
有效性这样理解，如果最终决策值始终是一个默认值，那其实是没有意义的。例如在数据库提交时，若每次决策都是「回滚」，虽然不会破坏一致性，但所有合法事务
都会回滚，这显然是不合理的。  
终止性也是一个重要的特性。一致性定了如何选择一个决策值，却没有定义何时进行这样的选择。因此，共识算法需要终止性来保证系统不停向前运转。而不是一直
停留在一个决策中无法结束。这样的共识算法是不实用的。

### 5. 通信模型
分布式系统建立在许多通过网络或其他方式进行通信的节点之上，通信机制的不确定性会限制共识算法的设计。通信模型定义了不同消息的延迟对于分布式系统的限制
能力。总的来说，存在三种类型的通信模型：同步、异步、部分同步模型。

#### 5.1 同步模型
同步模型中，节点之间的通信延迟存在一个已知上限，超过上限则认为对方节点故障。这是一个非常理想的通信模型，早期的分布式一致性算法都在此模型假设下设计的。

#### 5.2 异步模型
异步模型中，没有通信延迟上限，可以包含任何异常情况，如通道问题、节点本身问题等。相比同步模型，异步模型更为符合现实情况，也就更通用。一个适用于
异步模型的共识算法，也必然适用于同步模型，但反之不成立。
>在异步模型中设计一个完美的共识算法被证明是**不可能**的！

#### 5.3 部分同步模型
介于同步和异步模型之间。于1988年在某论文中提出。模型假设一个全局稳定时间GST，在GST之前，系统可以处于异步状态，但在GST之后，系统可以恢复到同步状态。
然而该模型中的GST是未知的，也就不知道什么时候达到同步状态。这个模型同样贴合现实世界中对共识算法的需求，即共识总可以在同步状态下达成，当出现网络
问题时，共识会出现一段时间的阻塞，直到网络正常。因此，这个模型中的共识算法设计首要保证的是系统进入异步状态时的安全性（可以阻塞，但不要产生错误共识），然后在
进入同步状态后产生正确共识。  
这个模型是许多共识算法的模型基础，如Paxos、ViewStamp Replication、PBFT。

### 6. FLP定理
1985年，Fischer、Lynch和Patterson三位科学家发表了论文，提出了著名的FLP定理，它是分布式系统领域的最重要定理之一。该定理给出了一个重要的结论：
>FLP定理：在一个异步通信网络中，只要存在一个故障节点，就不存在一种完美的共识算法可以正确地终止（使所有节点达成一致）。

FLP定理是在一个比异步通信更强的通信模型下得出的结论，如果在这样一个更强的通信模型下都无法保证共识算法的终止性，那么在现实中更弱的通信模型下也不可能
达到这种保证。  
该定理假设系统中不存在拜占庭错误，并且消息传递是可靠的，即消息传递延迟未知，但最终都会成功传递且只传递一次。也就是说FLP定理假设网络消息可能出现延迟，
但是不会出现丢包、重复包的情况，这是一个比现实网络更可靠的网络假设条件。但即便是在这种网络假设下，FLP定理也证明了在任意时间停止某个节点/进程，会导致
任何一个共识算法都无法达成最终一致，更不要说现实网络中还存在网络分区与拜占庭错误等问题了。（网络分区指的是在系统中由于部分节点网络不通导致整个系统
被划分为不同的区域的现象）  
因此，如果不对通信模型做进一步的假设，或者对容错类型做更大的限制，那么该问题就不存在一个完美的解决方案。  
FLP定理告诉人们，不用再想方设法地设计一个在异步网络中始终能够达成一致的共识算法。因此，后续的共识算法设计通常会在某些方面作出妥协。例如，网络假设不再是
异步模型而是部分同步模型，即允许存在一定时间的异步网络状态，在此期间无需达成共识，但只要等到网络恢复到同步状态，就可以立即达成共识。虽然这样对系统活性
有一定的影响，但是只要能够保证系统安全性，依然是一个可接受的共识算法。例如，Paxos理论上也会出现活锁，但其能够保证即使出现活锁整个算法也是安全的，那么在
实际场景中，只要活锁结束了，就可以继续推进共识了。
>FLP定理在论文中有其完整证明过程，非数学专业不易看懂，感兴趣者请自行查阅资料。

所以目前已知的共识算法都会采用下面的部分假设：
- 故障模型：非拜占庭故障/拜占庭故障；
- 通信类型：同步/异步；
- 通信网络连接：节点间直连数；
- 信息发送者身份：实名/匿名；
- 通信通道稳定性：可靠/不可靠；
- 消息认证性：认证消息/非认证消息；

### 7. CAP定理
2000年，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出了CAP猜想。两年后，MIT的Seth Gilbert和Nancy Lynch从理论上证明的CAP猜想。
此后，CAP理论成为分布式领域公认定理。CAP定理认为一个分布式系统中最多只能同时满足以下三种特性中的两种：
- 强一致性（Consistency）：即当系统中任意节点完成了一次写操作后，那么其他任意节点读取出来的结果必须是最新结果，或者返回错误。这是最高级别的一致性，它的
实现代价通常非常之大，所以在工程实践中，通常放宽至较弱的一致性，如最终一致性。
- 可用性（Availability）：指来自客户端的请求在一定时间内必须收到正确回应，即服务一直可用。
- 分区容错性（Partition tolerance）：指当系统出现了网络分区问题时，系统仍然能够对外提供服务。

CAP定理告诉人们，在设计分布式系统时，不必奢求同时满足上述三种特性，必须选择性地做出取舍，才能设计出一个实际可用的、高效的系统。在分布式网络环境中，
由于网络分区是常态，因此一般在一致性和可用性上做权衡，如AWS推出的分布式数据库Dynamo就是舍弃了一致性的例子，而谷歌的GFS则舍弃了可用性。

## 共识算法分类
从传统分布式一致性算法逐渐发展到现在区块链共识算法的百花齐放，共识算法的发展已经走过四十个年头。不同共识算法侧重点不同，它们面临的问题、环境也不同。
下面从几个角度对共识算法进行分类。

**容错类型**  
根据是否解决拜占庭错误分类：
1. 拜占庭容错共识算法：PBFT、PoW、PoS、DPoS
2. 非拜占庭容错共识算法：Paxos、Raft

通常来说，在公链环境下必须使用拜占庭容错算法，在联盟链中可以根据参与方之间的信任程度进行选择。

**算法确定性**  
1. 确定性共识算法：Paxos、Raft、PBFT
2. 概率性共识算法：PoW、部分PoS

确定性共识指共识决策一旦达成，就不存在回退可能性。这类共识算法通常是传统分布式一致性算法及其改进版本；概率性共识是指已经达成的共识在未来一定概率
回退，这个概率随着时间的推移会趋近于0，这类共识算法通常应用于公链上。

**选主策略**  
1. 选举类共识算法：Raft、PBFT
2. 证明类共识算法：PoW、PoS

选举类是指通过投票选举出块节点，同一节点可以连续多轮作为出块节点存在。这类共识算法通常是传统分布式一致性算法及其改进版本；证明类是指出块节点需要
通过某种方式证明自己具备某种能力，从而获得出块权，这类算法通常每轮出块节点都不同，从而保证公平性，一般应用于公链。

## 传统分布式一致性算法
这类算法一般不考虑拜占庭错误，只假设节点宕机、网络故障时，如何让多节点保持一致，因此也叫**非拜占庭容错共识算法**。这类算法多应用在数据库场景中。
比较著名的分布式一致性算法包括：
2PC、3PC、Paxos、ViewStamp Replication、Zab、Raft。

### 1. Paxos
>Paxos内容主要来自书籍《区块链技术指南——邱炜伟&李伟》

它是在一个异步模型下能够保证正确性且容错的一致性算法（也可以叫共识算法，此处不严格区分）。FLP定理指出了，在异步模型中只要存在节点故障，就不可能存在
一个可终止的共识算法。因此，Paxos也作出了一定的牺牲，它牺牲了「部分」的**活性（Liveness）**，从而保证了系统的**安全性（Safety）**。即在系统处于异步状态时暂停共识推进，
但只要有半数以上的节点恢复至同步状态，就可以推进共识，完成终止。总的来说，Paxos具有如下特点：
- 安全性：所有节点都会同意相同的决策，且决策一定是由某些节点提出的。
- 无保证的终止性：不保证收敛到一个最终决策，但只有在非常极端的场景下才会出现。
- 容错性：可以容忍少于半数的节点宕机，此时其他节点也可以达成一致。

需要注意的是，Paxos只是理论方案，直到后来才有了多个基于它的落地实例。另外，Paxos还代表了一系列一致性协议，包括Basic Paxos、Multi Paxos、
Cheap Paxos、Fast Paxos等协议及变体。其中，Basic Paxos主要描述了如何就一个值达成一致的决策，而Multi Paxos描述的是如何就一系列值达成一致的决策；
Raft就是Multi Paxos的变体。**下文简要描述Basic Paxos，也称经典Paxos**。

**Basic Paxos大致流程**  
首先，协议中约定存在以下几种角色，任意节点可担任多个角色：  
- Proposer（提议者）：是想要成为Leader（领导者）的节点，它提出了一个提议值并广播给其他Acceptor，收集它们的投票情况来决定最终提议值。任何时候可以有
多个Proposer；
- Acceptor（接受者）：一个从Proposer接收提议值的投票节点，根据一定规则拒绝或接受；
- Learner（学习者）：不参与投票流程，但必须从Proposer或Acceptor了解最后选出的Leader的提议值，并遵守该提议值采取适当行动；
- Leader（领导者）：在所有Proposer中最终选出的一个领导，大家都遵守它的提议值。

首先，所有参与节点需要初始化以下几个值：  
1. N<sub>a</sub>，V<sub>a</sub>：本节点接受的最大提案号及对应提议值
2. N<sub>h</sub>：本节点响应过的最大提案号
3. MY<sub>n</sub>：本轮共识中本节点提出的提案号

**阶段一：准备阶段**  
1. 如某节点想要发起提案，则直接选定一个提案号MY<sub>n</sub>（MY<sub>n</sub> > N<sub>h</sub>）,然后向集群中的大部分节点发送Prepare(N)请求，
其中N=MY<sub>n</sub>；
2. 每个Acceptor在收到一条Prepare(N)请求后，首先判断其中的提案号N是否大于本节点响应过的N<sub>h</sub>:
   1. 如果N ≤ N<sub>h</sub>（ 比它之前接受过的提案号小），则发送Reject拒绝消息给Proposer
   2. 否则，发送一个Promise(N<sub>a</sub>，V<sub>a</sub>)承诺消息给Proposer，并更新自己的N<sub>h</sub>=N，表示承诺本节点不会再接受任何提案号
   小于N的提案。如果本节点从未接受过任何提案，则发送的是Promise(Null，Null)消息。

**阶段二：接受阶段**  
1. 如果Proposer收到了超过半数节点关于Prepare(N)的响应，则从这些响应中找出提案号最大的Promise(N<sub>n</sub>，V<sub>n</sub>)，并向这些Acceptor
发送Accept(N,V<sub>n</sub>)请求；  
如果所有节点响应都是Null，那么Proposer就任意选择一个本地想要提出的提案值V，向这些Acceptor发送Accept(N,V)请求；  
如果任一节点响应Reject消息，说明已有其他Proposer提出更大提案号，此时又返回阶段一重新走流程。

2. 当Acceptor收到一条Accept(N,V)请求时，判断收到的N如果大于本地的N<sub>h</sub>，则发送一个Agree同意响应给Proposer，并更新本地N<sub>h</sub>=N<sub>a</sub>=N，
V<sub>a</sub>=V;  
否则，发送一个Reject拒绝消息给Proposer。

**活锁问题**  
在上述阶段二中，如果任一节点响应Reject消息，则当前Proposer会重走阶段一流程。这就可能导致一种情况，那就是若干个Proposer相继提出包含更大提案号的
提案时，使得Paxos进入活锁状态，从而无法达成共识。解决办法是选择一个固定的Proposer，或者给不同的Proposer设置不同的超时时间（随机数）来减小这种情况
发生概率，但是在异步网络中无法完全避免。

**无法逃脱FLP定理**  
在系统处于异步状态时（因网络异常或节点故障导致节点之间无法同步通信），Proposer如果可以收到过半数Acceptor节点的响应，那么系统仍然能够达成共识，
保证了**安全性(Safety)**；但也可能收不到过半数Acceptor节点的响应，就会导致系统共识推进陷入停滞状态，牺牲了一定**的活性（Liveness）**，
直到与多数节点的通信恢复。

**Paxos优点**  
- 平等共识：没有节点拥有特殊权限，任何节点都可以发起提案；
- 特殊排序规则：提案号的排序规则保证了即使多个Proposer同时提出不同提案值，最后也能收敛到一个最终值；
- 绝大多数共识：Paxos不要求每轮共识都等待所有节点完成投票，而是仅需要过半数节点的投票。因此它也是一个容错的算法。在不考虑节点作恶（拜占庭错误）的情况下，
Paxos在网络分区后也能保证系统安全性；

**Paxos缺点**  
Paxos是一个典型的非拜占庭容错共识算法，能够解决在一定程度上异步网络下的分布式一致性问题。但其算法晦涩难懂，在实践时会碰到不少问题。因此后面很多共识协议
是基于Paxos的二次设计，目的是为了适应不同场景，且有助于理解和实现。例如Raft、Chubby、Zookeeper、etcd等都是应用广泛的基于Paxos的共识协议。下文将会
重点介绍Raft，因为它在联盟链和私链上得到了比较广泛的应用。


### 2. Raft
尽管Paxos是一个非常有影响力的共识算法，可以说是奠定了分布式一致性算法的基础，但是由于其难以理解导致实现难度大，沉寂了很长一段时间。直到Chandra、Griesemer、
Redstone将其用到Chubby中实现了一种分布式锁服务，Paxos才渐渐为人所知并名声大噪。直到今天，想要实现一个完整的Paxos依旧非常困难，因此，出现了
非常多的Paxos变体，其中最著名的当属Raft。  
Raft是一种用来管理日志复制的一致性算法（共识算法）。它是一个为真实世界应用建立的协议，注重协议的落地性和可理解性。它具备Paxos的容错性和性能，
不同之处在于它将一致性问题分解为相对独立的三个问题，分别是领导选举、日志复制和安全性。在一些区块链系统中，会使用Raft来实现记账共识。

#### 2.1 Raft基础概念
首先，在Raft协议中，节点可以是三种角色之一：Leader、Candidate、Follower。下面详细说明各角色特点：
- Leader：处理所有来自客户端的请求，Follower若收到客户端的请求则转发给Leader处理（出现Leader时，则没有Candidate节点）；
- Candidate：是选举Leader阶段中出现的过渡状态，任何节点在发现Leader节点故障后都可以成为Candidate；
- Follower：节点的初始角色，属于被动角色，不主动发送任何请求。在选举阶段中若Follower未收到Leader的心跳消息，则转换为Candidate，然后去竞争Leader角色；

Raft协议将时间划分为任意不同长度的term（任期）。任期使用连续数字表示，每个任期的开始都是一次选举，若一个Candidate赢得了选举，则它在改任期剩余时间内
担任Leader。如果根据选票情况无法选出Leader，那么就会立即开始下一任期（选举）。

#### 2.2 过程详解

**阶段一：Leader选举**  
首先，所有节点均初始化为Follower。若收到来自Leader或Candidate的消息，则会一直保持Follower角色。Leader会向所有Follower周期性
的广播心跳消息来保持自己的地位。如果Follower在一个周期（为了避免选举冲突，这是一个时间范围：150~300ms）内没有收到Leader的心跳消息，那么它会开始选举，
准备竞争Leader。在开始选举前，Follower会自增它当前的任期号，然后转换为Candidate。随后，Candidate会给自己投票并向集群中其他节点发送RequestVote请求，
一个节点会一直处于Candidate角色，直到发生下面两种情况：
1. 有人（包括自己）赢得了选举
2. 一段时间后无人赢得选举

下面详细说明这两种情况：
1. 一个Candidate在一个任期内如果收到集群中过半节点数的投票就会赢得选举。投票原则：根据先到先服务原则，Follower会投票给它收到的第一个RequestVote请求
对应的Candidate。Candidate成为Leader会周期性的向其他节点广播心跳消息，建立自己的Leader地位，阻止新的选举。
2. 当一个Candidate在等待其他节点投票时，可能会收到Leader的心跳消息（Leader选完了）。如果这个心跳消息里的任期号大于自己的任期号，则Candidate
承认该Leader合法，并转换自己为Follower角色。否则拒绝该心跳消息，继续保持Candidate角色。
3. 一段时间后，没有节点赢得选举。这种情况一般出现在多个Follower同时成为Candidate的时候，此时每个Candidate都会发生选举**超时**，并通过自增任期号来发起
新一轮的选举。为了避免无限选举，在发起新一轮选举前，Candidate会产生一个随机选举超时时间（150~300ms内），这样就可以让大多数情况下只有一个节点会率先超时，然后赢得选举。

**阶段二：日志复制（对应区块链中的记账过程）**  
Leader选出后，就开始接收客户端请求。每个客户端请求都包含一条需要被复制状态机执行的命令，Leader把这条命令作为新的日志条目加入日志记录，然后向
其他Follower广播AppendEntries请求，要求其他节点复制这个日志条目。当这个条目录被所有节点复制完成后，Leader会将它应用到自己的状态机中，并向客户端
返回执行结果。如果Follower在一定时间内没有响应Leader（Follower崩溃了/执行缓慢/网络丢包），那么Leader会无限重发AppendEntries请求，
直到所有Follower最终都存储了日志条目。  
当日志条目已被复制到大多数Follower时，则可以称它是可被提交的Committed状态。Leader会记录它所知道的该日志条目的最大索引值（在日志中的顺序序号），然后
将这个索引值添加在之后的AppendEntries请求中（包括心跳消息），从而让其他节点知道这个日志条目已被提交，然后Follower就会将该日志条目应用到本地状态机执行。

**阶段三：Leader失联**  
在阶段二中，若发生网络故障或网络分区，导致Leader不能访问多数Follower。则这多数Follower会重新选举Leader，当网络恢复后，根据任期号规则，旧Leader会
变成Follower，且失联过程中旧Leader的任何更新都不作数，需要回滚。然后接受新Leader的更新。

### 3. 传统分布式一致性算法小结
基于Paxos的一致性（共识）协议有Chubby、Zookeeper、etcd等，这些共识算法广泛应于于各类分布式系统中。例如，谷歌的GFS和BigTable采用了Chubby的分布式锁协议；
Yahoo公司的Hadoop系统和OpenStack、Mesos采用了Zookeeper；kubernetes和CoreOS采用了etcd协议等。除了超级账本的Fabric 1.0用了基于Zookeeper的
Kafka做排序引擎外，这些协议在区块链场景不是很多见。

## 区块链共识算法
传统分布式一致性算法只能运行在不存在拜占庭节点的场景中，如数据库备份、日志备份、分布式锁等。但是在区块链（公链）系统中，没有对节点做鉴权，所以
利益的驱使下一定会存在恶意节点，因此在选择区块链共识算法的时候，必然要考虑节点作恶的情况，如双花攻击、51%算力攻击等。在区块链共识算法选择时，通常
根据两种思路选择：
1. 公链项目，考虑节点规模和安全性。通常选择能够容忍拜占庭故障的共识算法，如PoW、Pos、DPoS等；
2. 联盟链和私链项目，更考虑高性能和低延迟。通常选择经典PBFT、Raft等。

在公链项目中，因为存在拜占庭节点和节点规模较大的问题，只能采用最终一致性的共识算法，没法采用强一致性算法（如Raft）。在联盟链和私链项目中，
通常对共识算法有强一致性和高性能需求，而且一般来说也不会出现拜占庭故障（节点加入要接受鉴权）。因此，在这个场景下可以考虑采用传统分布式一致性算法（非拜占庭容错共识算法）。
在Hyperledger的Fabric项目中，共识模块是被设计为可插拔的，支持PBFT、Raft等算法。目前在区块链项目中，比较常见的非拜占庭容错共识算法是Raft。  

### 1. PoW共识算法
最早在1993年由Cynthia Dwork与Moni Naor在学术论文中提及，并于同年由Markus Jakobsson与Ari Juels正式提出。起初，PoW主要是用于防止垃圾邮件
的产生，2008年，PoW作为共识算法应用在比特币系统中。

TODO

