# 以太坊技术细节（整理）

### 目录

TODO

## 架构图

<img src="./images/ethereum_arch.jpg" height="400" width="700">

## 数据层

位于区块链架构的最底层，在数据层中数据键值对形式存在LevelDB数据库中，使用MPT（Merkle Patrcia Tree）作为数据结构来组织和管理。数据组成一个个区块，
区块中包含交易列表，交易执行会改变账户状态，进而改变以太坊的全局状态。

### 1. 账户原理

与比特币相比，以太坊的最大优点之一就是它使用传统账户余额模型，而不是UTXO模型，这使得以太坊账户可以拥有多种状态。下面从账户类型、账户状态、账户生成和账户管理这四个方面来讲解账户与原理。

#### 1.1 账户类型

在 [以太坊介绍](./ethereum_intro.md) 中我们简单介绍了账户分为外部账户和和合约账户，外部账户由人为创建，而合约账户可以由外部账户或合约账户创建。 这决定了两种账户在宏观上的不同表现。

**外部账户**可以通过个人私钥对交易签名，发送交易给另一个外部账户或合约账户。在两个外部账户之间传送的消息只是简单的价值转移；从外部账户到合约账户的消息则会激活合约账户中的合约代码，
允许合约代码执行响应逻辑，包括转移代币、修改合约状态、执行特定逻辑运算、创建新合约、调用其他合约代码等。

**合约账户**被合约代码控制，与外部账户不同的是，合约账户不可以自己主动发起交易，只能在收到一个交易后才能触发响应（即被动执行）。收到的交易可以是外部账户发起其他合约账户的代码调用。
同时合约之间还可以通过「消息」或「内部交易」进行通信，消息或内部交易也类似于交易，不过与交易的不同点是它们不是由外部账户产生，而是由合约账户产生。
而且它们只是虚拟对象，没有像交易一样被序列化并被记录到区块链中，而是只存在于以太坊执行环境中。当一个合约发送一个内部交易给另一个合约时，另一个合约中的代码就会被执行。 下图展示它们之间的调用逻辑：

<img src="./images/ethereum_tx_call.jpg" height="202" width="500">

从图上可以看出，以太坊上的任何动作，总是由外部账户先触发，然后产生交易，再根据情况决定是否触发合约账户以及后续的调用逻辑的。

#### 1.2 账户状态

外部账户和合约账户的状态有所不同，但都包含四个字段：

- nonce：在外部账户中这个字段表示由此账户地址发出的交易数量，该字段会在发送交易时用来防止双花。在和合约账户中表示账户所创建过的合约数量；
- balance：余额，以wei为单位，1ether=10<sup>18</sup>wei；
- storageRoot：账户存储内容的MPT的根节点哈希值；
- codeHash：在外部账户中这个字段是一个空字符串的哈希；在合约账户中表示这个账户的EVM code（编译后的合约字节码）的哈希，当账户收到一个消息调用时，代码就会被执行。
  与其他字段不同的是，codeHash是不可变的，可以被当做索引来从状态数据库中获得响应的EVM code。

一个预编译合约账户和一个被销毁的合约账户的状态都是空，为空的时候表示账户不被包含在以太坊全局状态中了。

一个新生成的外部账户，只有账户的nonce和balance为空，账户状态不为空。

#### 1.3 账户生成

**【外部账户生成】**  
一个外部账户是通过一对公私钥的形式体现的。公钥代表账户地址，私钥被编码在一个钥匙json文件中，可以用任何文本编辑器打开查看。 但文件中的私钥是在创建账户时设置了密码加密存储的，所以必须同时拥有私钥和私钥密码才有账户的所有权。

钥匙文件被保存在以太坊节点data/keystore目录中，同一个节点data/目录下的账户属于同一个钱包，一个以太坊节点可以设置不同的data/目录来创建多个钱包。

**【合约账户生成】**  
一个新的合约账户是通过部署一个合约来生成的。合约账户不受私钥管理，通常是受合约发布者的管理，并且这种所有权可以通过写在合约里的函数实现所有权转移、继承等。

合约所有者还拥有销毁合约的权利，销毁合约后合约地址上剩余以太币将会发送给指定目标，然后合约账户上的所有状态会被清除。但合约代码并没有从区块链上移除，
历史区块不受影响，只是合约被销毁后这个合约所有函数都不能被调用，再向合约地址转入以太币将无法被转出。

#### 1.4 账户管理

以太坊客户端中，管理账户信息的模块可以管理多个钱包，每个钱包管理多个账户。  
上述钱包是指用于管理账户的功能模块，即存放私钥的容器。我们平常所说的钱包一般是指拥有用户界面的应用程序，可用来访问用户资金，管理秘钥和地址、创建/签署交易、与合约交互和作为DApps入口。

### 2. 交易原理

交易的定义：以太坊交易是指一个签名数据包，用于从一个账户向另一个账户转移以太币、调用合约方法或部署一个新合约。交易分为两种类型：消息通信和合约创建，
两者都是由外部账户创建并提交到以太坊网络的，然后由以太坊网络传输，并在以太坊区块链上被记录。由此可见，交易是连接外部世界和以太坊内部状态的桥梁。

本节按照交易从产生到上链的基本流程来详细介绍以太坊交易原理。

#### 2.1 创建交易

创建交易需要在客户端填充以下交易信息：

- nonce：发送者账户中的nonce，表示发送者总共发出的交易数量
- gasPrice：发送者愿意支付的一个gas单位的价格
- gasLimit：发送者设置的执行这个交易可使用的最大gas数量
- to：接收者地址，在合约创建交易中为空，使用默认零地址
- value：发送者向接收者转移的wei的数目，或者是创建合约时作为合约账户的初始wei数目
- v,r,s：用于产生标识发送者的签名信息
- init：仅存在合约创建类型的交易中，用来初始化新合约账户的EVM代码片段。init值会执行一次，然后被丢弃。第一次执行init时，它返回一个账户代码体，即永久与合约账户关联的一段代码
- data：一个不限制大小的字节数组，作为交易的附加信息或合约代码或合约参数

#### 2.2 交易签署

以太坊目前使用的签名方案是在EIP-155中指定的包括交易重放保护的新签名方案。EIP-155向交易数据结构中添加了三个字段：v,r,s，其中r和s初始为0，v初始为链标识符。
三个字段在交易序列号前添加到交易数据中，因此它们会影响交易hash。v保证了链标识符的不可篡改，因为如果链标识符被篡改，签名将失效。因为签名的有效性取决于链标识符，所以交易无法在另一个链上重放。
> 交易重放保护方案的内容是：在签名前的交易数据中添加了链标识符（chain-id）。确保了在一个链上（如以太坊主网）创建的交易不能再其他链上（如ETC或Rposten测试网）重放。

可用的链标识符如下表：

| 区块链名称            | 链标识符 |
|------------------|---|
| ETH主网            | 1 |
| Expanse          | 2 |
| Rposten          | 3 |
| Rinkeby          | 4 |
| Rootstock主网      | 30 |
| Rootstock测试      | 31 |
| Kovan            | 42 |
| ETC主网            | 61 |
| ETC测试            | 62 |
| Geth private 测试  | 1337 |

#### 2.3 交易广播
以太坊使用P2P网络，网络中任意节点都可以创建、发送、接收和验证交易。广播始于创建交易的节点，然后传播到相邻的其他节点。

#### 2.4 交易提交
节点收到新交易后，会把它先放入交易内存池中。后者包含两个列表：queue列表和pending列表。新交易先放入queue列表中，接着从queue列表转移到pending列表中。

#### 2.5 交易执行
添加到pending列表中的交易是待处理交易，准备被执行。执行是在矿工挖掘一个新区块时进行的。矿工从pending列表中选择交易，把它交给EVM执行，并同时把它打包进区块中，不会等待执行结果。

#### 2.6 交易存储
交易执行后会返回一个收据，其中包含交易后账户状态的变化。当交易所在的区块被添加到区块链上时，此收据才会被提交到底层数据库中存储下来。这样，我们的交易就完成了从创建到被签署、传播、上链全过程。
它改变了以太坊这个状态机的状态，并在区块链上留下了不可磨灭的印记。

### 3. 区块从创建到入库
与比特币一样，在以太坊中，区块仍然是交易的载体。打包区块的过程是通过不断寻找一个小于系统给定哈希值的数来获得记账权。与比特币不同的是，以太坊的区块由交易列表和叔区块构成。
同样，由于网络延迟，最早打包区块的节点并不一定最先将区块广播至网络，那就可能发生同一时刻多个矿工打包出区块的情况，这个时候就涉及到链的分叉。
分叉时会选择多个分叉链中总难度最高的链作为主链，该链上的区块会获得奖励，而其他分叉链上的新区块只有在被后续作为uncle区块时才会获得奖励，否则就是没有价值的孤儿区块。

#### 3.1 区块结构

<img src="./images/ethereum_block_structure.png" >

**------------------------【以太坊区块结构图：header+body】------------------------**

区块头字段解释（其中ommer同uncle）：
- parentHash：前一个区块（父区块）的256位hash
- ommersHash：区块关联的uncle区块的256位hash
- beneficiary：矿工用于接收交易费的以太坊的地址
- stateRoot：区块中所有交易被执行完且区块被确认后，状态树根节点的256位hash
- receiptRoot：区块中所有交易的收据所组成的树的根节点的256位hash
- transactionRoot：区块中所有交易所组成的树的根节点的256位hash
- logsBloom：区块中所有交易的收据的日志组成的bloom过滤器
- difficulty：区块难度值，可以根据父区块的难度值和时间戳计算得到
- number：区块高度，创世区块高度为0
- gasLimit：区块可用的gas数目上限，在区块创建时设置。可以根据父区块的gasUsed同gasLimit * 2/3 计算得到 
- gasUsed：区块中所有交易用掉的gas数目之和
- timestamp：区块初始化的时间戳
- extraData：区块的附加数据，最多32字节
- mixHash：一个256位hash，用来与nonce一起证明当前区块执行了足够的计算量
- nonce：工作量证明过程中生成的一个64位hash，与mixHash一起证明当前区块执行了足够的计算量

**【区块体】**  
区块体包含交易列表和引用的uncle区块列表。交易列表是从交易池中选择进入区块的一系列经过验证的交易，叔区块是区块体中一个特别成员，从业务上来说，它不是必须的，
而且它的出现会使得区块计算hash需要更长时间。引用uncle区块的目的是为了使主链获得更多安全保证，降低以太坊网络中那些计算能力特别强大的节点对区块产生有过大影响力的风险。
通过对uncle区块打包者的奖励，来调动各节点计算资源分布的均匀性，防止这些节点破坏去中心化这个根本宗旨。

#### 3.2 区块生成
除了创世区块，其他区块都是由矿工创建并添加到网络中的。区块创建就是矿工根据一定规则从交易池中选择一系列经过验证的交易进行打包，生成区块头和区块体的过程。
矿工在网络中负责接收、转发、验证、打包交易。以太坊1.0时代仍然使用PoW算法来竞争记账权，以太坊中这一竞争过程称为区块的**封印**（Seal）。

#### 3.3 区块封印
我们所说的挖矿过程其实包含了区块创建和封印两阶段。第一阶段先创建出完整的新区块，其中包括区块头部分属性、交易列表、uncle区块等，并且所有交易已经执行完毕，
所有收据也收集完毕，各账号状态更新完毕。只等第二阶段的封印结果返回，就可以填充区块头中剩余的部分属性，如Difficulty、Nonce、MixHash等。
封印完成后，区块可以被广播给其他节点。封印阶段消耗的计算资源远超创建阶段。

区块封印由共识算法完成。目前以太坊中的共识算法包括Ethash算法和Clique算法，在以太坊发展的第四个阶段，将会从PoW转为PoS，即采用基于PoW的Casper算法。
Ethash算法是目前以太坊主网采用的，Clique是测试网(ganache)采用的。封印过程不会增加或修改区块中任何跟有效数据有关的部分，封印目的是通过一系列复杂步骤选拔出本轮次有资格记账的矿工。

#### 3.4 区块验证
区块封印后被广播至其他节点，然后由其他节点进行验证是否有资格上链。验证包含四个步骤：验证区块头和uncle区块、验证交易、发放奖励、验证全局状态和工作量。

#### 3.5 选择主链
新区块在某个节点被验证通过后，还需要验证区块所在的链是否主链。由于以太坊生成区块的速度较快，同时生成多个区块的情况很多见，故每一时刻生成的基本都是一颗区块树。
那么主链就是该区块树中从根节点到叶子节点路径最长的链。为了形成路径共识，最终会选择具有最大计算量（总难度最大）的路径作为主链。

识别主链最直观的方式是比较从根走到叶子节点的路径长度，即除了创世区块以外总共走过的区块数量。路径越长，一般到达叶子节点的总体挖矿工作量越大。
但当出现到达两个叶子节点的路径长度相同时，就需要比较两个叶子节点的区块的总难度。新区块的总难度为它自己的难度值加父区块的难度值，因为区块头已经包含了难度值。
所以仅通过区块头就能比较已经完成的计算量。 TODO：优化这段话

#### 3.6 区块存储
在新区块确认加入主链后，区块中的数据才会被以键值对形式存入节点本地的LevelDB中。存入过程：
依次存入区块高度和区块哈希值的映射、上一个区块头哈希值、上一个区块的哈希值、快速同步链中上一个区块的哈希值、总体难度值、当前区块的RLP（区块头和区块体分开存入），
并将区块中所有收据存储为单个收据数组，用于在区块链重组期间重新安排丢弃的交易。经过以上流程，一个个区块被添加到区块链上，并存入LevelDB数据库中，形成以太坊的这条区块链。

### 4. 小结
至此，我们已经从数据层的角度讲述了以太坊中的账户发送交易、交易组成区块、区块构成区块链、区块数据入库的所有过程。



## PoS算法

比特币使用的PoW算法由于存在大量资源浪费，导致难以被更大规模的应用接受。对此，以太坊尝试使用股份/权益（stake）作为标准进行记账权的竞争，并把这样的共识算法定义为PoS（Proof of Stake，权益证明）算法。
关于PoS的更多细节请参阅[共识算法——传统PoS共识算法](./consensus.md#2-传统PoS共识算法) 。
> PoS的思想起源于企业的股份制：一个人拥有的股份越多，其获得的股息和分红也就越高。如果采用这种方式进行区块链系统的维护，则不需要过多资源消耗，也能够使区块链资产有自然的通胀。 节点通过投入一定量的虚拟币参与共识，根据持币情况获得打包新区块的权利，并获得奖励。

## Casper算法

进入以太坊2.0时代的标志就是上线了采用了Casper算法的Beacon区块链。Casper属于权益证明制（PoS）范畴，除了继承PoS机制低能耗、防51%攻击更安全的优势外，
还在现有PoS机制上增加经济惩罚机制，解决PoS机制本身存在的“无利害攻击”问题。
> Casper 共识机制是一种旨在将以太坊从 1.0 版过渡到 2.0 版的协议，也称为“Serenity”计划。 以太坊 2.0 的长期目标是使其更快、更高效和高度可扩展。

Casper的上线意味着以太坊将不再需要挖矿来产生区块，而是通过基于股权的投票选出验证节点，然后由验证节点产生区块。

### 1. CBC和FFG

目前为止，在以太坊生态系统中已经有两个共同开发的Casper版本：Casper CBC（Correct-by-Construction）和Casper FFG（Friendly Finality Gadget）。
CBC版本最初由以太坊基金会研究员Vlad Zamfir提出。尽管对CBC的研究最初侧重于公链的PoS协议，但它已经发展成为一个更广泛的研究领域，其中就包括一系列的PoS模型。

Casper FFG的研究由以太坊联合创始人Vitalik Buterin主导。最初的提议包括混合PoW & PoS系统，但实施仍在讨论中，新提案最终可能仅使用PoS模型取而代之。

虽然两个版本都是为以太坊开发的，但Casper是一种PoS模型，也可以在其他区块链网络中推广和使用。

### 2. 以太坊2.0选择的共识算法

以太坊2.0选择的共识算法是Casper FFG + LMD-GHOST，二者结合起来叫做**Gasper**。其中LMD GHOST是被FFG和CBC同时选择的分叉选择规则。
> FFG论文：https://arxiv.org/abs/1710.09437  
> LMD GHOST：https://vitalik.ca/general/2018/12/05/cbc_casper.html#lmd-ghost

### 3. 算法细节

TODO

## LMD-GHOST协议

TODO




---

参考

- [《区块链技术开发指南-马兆丰》](https://baike.baidu.com/item/区块链技术开发指南/56688853?fr=aladdin)
- [Beacon Chain Fork Choice](https://github.com/ethereum/annotated-spec/blob/master/phase0/fork-choice.md)