# 比特币技术细节（整理）

### 目录
TODO

---

比特币的底层网络架构是p2p网络，不依赖于任何单一服务器，而且比特币的源代码是开源的，由比特币社区共同去维护的。
所以比特币不受任何一个单一组织的控制，开发者，矿工，交易所，用户共同组成比特币社区，相互协调维护比特币的发展。比特币的运行依赖于
比特币的每一个节点，但是单一节点运行失败并不影响整个比特币网络。

## 四个关键设计

- p2p网络技术
- 分布式账本（区块构成的链）
- 工作量证明共识机制
- 最长链原则

1. p2p网络技术：TODO
2. 分布式账本（区块链）：首先，交易信息需要存储，没有了中心机构，比特币将它存储在全网所有加入比特币网络的节点之上，这叫做分布式账本。它是以N个区块链接起来的形式工作的，
   每个区块相当于一个小账本，记录了多笔交易信息和上一个区块的地址。
3. 工作量证明（Proof of work，记账权）：如何保证每个账本的一致性成了一个问题，比如A本来只有1元，在两个节点的记录结果却不同可不行。比特币引入记账权的概念，网络中的节点若要想要获得
   记账的权利， 就必须完成一道系统提供的数学题（耗费一定的算力和时间进行一项哈希计算工作，直到算出一个满足条件的结果结束）。谁做得快就就优先获得记账权。
   这也叫做工作量证明，它是区块链账本的安全机制。
4. 最长链原则：传统交易基于中心机构进行，没有双花（双重支付）问题，但区块链架构之上该如何解决？那就是最长链原则。同一笔钱的第二次以上的交易一定是无效的，
   并且第一次和第二次交易不可能存在于同一个链条中（把同一个链条看做一个中心账本），所以第二次交易所在区块（账本）一定是从主链上分叉出去的，这就导致
   链条分叉，从上面得知想要记账先要获得记账权，就得有很高的算力，因为比特币系统中任意节点都可以来竞争记账权，显然主链增加的速度一定是极快的，分叉的链条
   就一定很慢，因为只有攻击者独自维护分叉链条，这就变成了一场算力比拼，显然攻击者的算力无法与全网算力竞争，最终就只有主链被系统承认。


## 分布式账本（区块链）

#### 账本（区块）是如何链接的？
整个账本（一条区块链）由一串使用密码学算法产生的区块（单个账本）连接而成。每一个区块上写满了交易记录，区块按顺序相连形成链状结构，也就是区块链大账本。  
矿工在生成新区块时，需要根据前一个区块的唯一哈希值（叫做区块哈希）、新交易区块和随机数，来计算新的区块哈希和随机数。也就是说每一个
区块都是在前一个区块数据的基础上生成的，该机制保证了区块链数据的唯一性。  
区块中的主要数据就是一系列交易，第一条交易通常是Coinbase交易，也就是矿工的挖矿奖励，后续交易都是用户的交易。

![](./images/The-structure-of-a-Blockchain-A-block-is-composed-of-a-header-and-a-body-where-a-header.png)
———————————— **图1【区块的大致组成和链接方式】** ————————————

  
<img src="./images/bitcoin_block_detail.jpg" style="zoom: 80%">

———————————— **图2【Merkle根的组成结构】** ————————————

## 比特币分叉

指的是区块链条的分叉，又分为硬分叉和软分叉。  
为什么会分叉？  
因为比特币系统中的1个区块大小为1MB，区块限制了容纳交易的笔数。比特币对单笔交易的大小没有限制，一般来说一笔交易的大小为250B，所以一个区块大约
能容纳4000多笔交易，然后比特币系统规定10分钟产生一个新区块，通过计算得知比特币系统的每秒可交易笔数 4000/600≈7笔。显然，对于全球用户来说，
这个速度可太慢了，所以人们就想到了对比特币区块扩容，这就要修改比特币软件代码了。

#### 什么是分叉？

软件由于**方案优化、BUG修复**等原因进行升级是一种非常常见的现象。如手机应用等传统软件，升级非常简单，只需厂商发布，用户接 受升级即可。  
但是对于比特币这种去中心化的系统，升级是非常困难 的，需要协调网络中每个参与者。软件升级意味着运行逻辑的改变， 但是在比特币中，
升级必然会导致不同节点在一定时间内运行不同的版本，于是就会产生分叉。

分叉主要包含软分叉和硬分叉两种。如果比特币升级后，新的代 码逻辑向前兼容，即新规则产生的区块仍然会被旧节点接受，则为软分叉；
如果新的代码逻辑无法向前兼容，即新产生的规则产生的区块无法被旧节点接受，则为硬分叉。

#### 1.硬分叉
比如对区块大小扩容从1M到4M，升级后的节点产生的4M区块广播到网络中，那些旧节点会认为这个区块是非法的，不认可。旧节点仍然会基于原来的1M区块
的链条继续产生新区块。如此新旧节点不兼容就导致主链分叉，产生第二条链。  
>注意：新节点会认可旧节点产生的区块

这种分叉是永久性的，只要旧节点不更新软件，原先的主链就不会消失，并且无法合并两条链，这就叫做硬分叉。
>2018年，区块的扩容导致最初的比特币主链分叉出新的链条，形成了现在的**BitCash**，一个新的基于区块链的加密货币；旧链条仍然是比特币。
> 在BCH之后，又发生了多个分叉。理论上，任何参与比特币网络的节点（矿工）都可以分叉。

#### 2.软分叉
同样是比特币协议发生了部分变化，但旧节点仍然能接受新节点产生（挖出）的区块，并基于新区块继续添加旧区块。  
软分叉由于向前兼容，新旧节点仍然运行在同一条区块链上，并不会产生两条链，对整个系统影响相对较小。  
到目前为止，比特币发生过多次软分叉，如BIP-34，BIP-65，BIP-66，BIP-9等。其中比特币改进建议（Bitcoin Improvement Proposal, BIP）
指的是比特币社区成员针对比特币提出的一系列改进建议。
>软分叉虽然对系统的影响较小，但是为了保证向前兼容，不能新增字段，只能在现有数据结构下修改，即可升级的内容非常有限。  
> 同时，因为这些限制，软分叉一般升级方案比较复杂，复杂的方案往往更容易产生BUG，并且可维护性很差。

## 一些通用概念

### 1. 矿工和挖矿
指的是参与到比特币网络中不停消耗算力去试图把新的交易打包成新区块的节点，这个尝试打包的过程就是挖矿；它们的动力来自于产生新区块而获得的比特币奖励

### 2. 挖矿过程(原理)
比特币挖矿的逻辑过程如下：
1. 打包交易，检索待确认交易内存池，选择包含进区块的交易。矿工可以任意选择，甚至可以不选择(挖空块)，因为每一个区块有容量限制(当前是1M)，所以矿工
也不能无限选择。对于矿工来说，最合理的策略是首先根据手续费对待确认交易集进行排序，然后由高到低尽量纳入最多的交易。
2. 构造Coinbase，确定了包含进区块的交易集后，就可以统计本区块手续费总额，结合产出规则，矿工可以计算自己本区块的收益。
3. 构造hashMerkleRoot，对所有交易构造Merkle数。
4. 填充其他字段，获得完整区块头。
5. Hash运算，对区块头进行SHA256D运算。
6. 验证结果，如果符合难度，则广播到全网，挖下一个块;不符合难度则根据一定策略改变以上某个字段后再进行Hash运算并验证。
>Coinbase是什么：每个区块都会包含至少一个交易，第一笔交易就叫做coinbase，每笔交易都包含了input和output，正常交易的input是转账来源方的钱包地址，
> output就是接收方的地址；而coinbase的input没有任何地址，只有output记录了给与矿工打包区块成功的奖励和手续费。Coinbase是一笔特殊交易。

这个算法也叫做**POW**（Proof Of Work）。  
合格的区块条件： **SHA256D(BlockHeader) < F(nBits)**  
其中，SHA256D(BlockHeader)就是挖矿结果，F(nBits)是难度对应的目标值，两者都是256位，都当成大整数处理，直接对比大小以判断是否符合难度要求。

### 3. 不断的计算哈希值（挖矿）
比特币系统规定，打包产生的新区块的区块哈希值，必须小于给定的难度哈希值，这个区块才算有效。
区块哈希的大致计算方式：block_hash=Sha256D(BlockHeader)，而区块头包含了nVersion，hashPrevBlock, hashMerkleRoot, nTIme, nBits, nNonce这些字段；  

其中nVersion是比特币协议号，一般不会变化，hashPrevBlock是前一个有效区块的区块哈希，nBits由全网决定，每2016个区块重新调整，调整算法固定。
因此这三个字段可以认为是固定的，对于每个矿工都是一样，而矿工可以自由调整的是剩下三个字段：hashMerkleRoot,nTime,nNonce；  
其中nTime提供的修改空间非常有限，因为有效的区块时间由一个范围，范围由前一个区块决定，比前一个区块时间太早或者太延后都会被其他节点拒绝。
一般来说，矿工会直接使用机器当前时间戳。  
nNonce，提供2^32种可能取值；  
hashMerkleRoot，理论上提供2^256种可能，本字段的变化来自于对包含进区块的交易进行增删，或改变顺序，或者修改Coinbase交易的输入字段。 

在CPU挖矿时代，修改空间主要由nNonce提供，也就是不断的累加nNonce值然后进行哈希计算，然后判断哈希值是否小于难度值，循环往复。进入矿机时代，
nNonce提供的4个字节已经远远不够，搜索空间转向hashMerkleRoot。

### 4. 动态调整的难度哈希
比特币网络的难度是不断变化的，它的难度保证大约每10分钟产生一个区块，而难度值在每2015个区块调整一次：如果区块平均生成时间小于10分钟，
说明全网算力增加，难度也会增加，如果区块平均生成时间大于10分钟，说明全网算力减少，难度也会减少。因此，难度随着全网算力的增减会动态调整。

所以比特币的工作量证明被通俗地称之为挖矿。在同一时间，所有矿工都在努力计算下一个区块的哈希。而挖矿难度取决于全网总算力的百分比。  
比特币挖矿已经从早期的CPU、GPU发展到专用的ASIC芯片构建的矿池挖矿。
>比特币设计时本来打算每2016个区块调整一次难度，也就是两周一次，但是由于第一版代码的一个bug，实际调整周期是2015个区块。


## 密码算法

主要采用了**哈希算法**（SHA-256和RipeMD160）用于计算单个区块的唯一哈希值，保证区块信息无法被篡改，因为一旦篡改，哈希值将改变，
无法通过其他节点的区块验证，进而导致此区块被全网拒绝。所以少部分节点的修改是无意义的；  
采用了**非对称加密算法**（ECDSA）用于数字签名。

### 1. 哈希算法
又称散列算法、摘要/单向加密算法。具有不可逆推性，它把任意长度的字节输入转换为固定长度的输出。  
一个优秀的哈希算法需要满足较低碰撞率。  
#### 1.1 比特币中的Merkle Hash
在区块的头部中，有一个MerkleRoot字段，它是将当前区块里的所有交易记录的Hash使用二叉树的方式，
层层通过hash字符串相加的方式并计算出新的Hash，直到最后一个节点Hash就是MerkleRoot，MerkleRoot是把一系列数据的哈希根据一个简单算法变成一个汇总的哈希。
在每一层计算中，如果是偶数个交易哈希，每两个交易哈希通过double_hash方式合成一个，其中
>data = tx1_hash_str + tx2_hash_str  
>double_hash(data)=sha256(sha256(data))

如果有单数，就把最后一份数据复制，再合成;如果只有一笔交易，那么直接使用这笔交易的hash作为MerkleRoot，通过这样不断进行金字塔式合成的方式，最后一定能计算出MerkleRoot。
详细计算过程如下：
1. 检查总交易数是否为偶数，不是则复制最后一笔交易，以得到一个偶数交易集合；
2. 将每一笔交易的哈希转换为小端序（比特币中的交易数据都是以小端序处理）；
3. 将转换字节序后的连续的两个交易哈希拼接起来，然后计算两次hash，即sha256(sha256(tx1_hash_str + tx2_hash_str))，将结果作为父节点；
4. 不断执行以上步骤，直到最后剩下一个hash值，将其转换为大端序，就得到MerkleRoot。

读者可以仅包含两笔交易的[区块#80000](https://www.blockchain.com/explorer/blocks/btc/80000) 为例计算其MerkleRoot是否与区块链浏览器上显示的一致。  

从MerkleRoot的计算过程可以得出结论：
**修改任意一个交易哪怕一个字节，或者交换两个交易的顺序，都会导致MerkleRoot验证失败**，也就会导致这个区块本身是无效的，所以，MerkleRoot记录在区块头部，
它的作用就是保证交易记录是完整的、未损坏和未修改的。MerkleRoot的优点如下：
- 验证（交易）数据的完整性，确认数据未经修改；
- 占用较小空间，方便存储和传输；
- 高效验证：数据格式高效，验证数据完整性只需几分钟。

MerkleRoot在其他软件中也有应用，如Git、Amazon DynamoDB和Apache Cassandra等。

####  1.2 比特币中的Block Hash
区块哈希，由区块头中的多个字段哈希计算后得出，所以一个区块自己的区块哈希并没有记录在区块头部。
区块头部的Prev Hash记录了上一个区块的Block Hash，这样，可以通过Prev Hash追踪到上一个区块。由于下一个区块的Prev Hash又会指向当前区块，
这样，每个区块的Prev Hash都指向自己的上一个区块，这些区块串起来就形成了区块链。区块链的第一个区块（又称创世区块）并没有上一个区块，因此，
它的Prev Hash被设置为00000000...000，部分区块链浏览器也将该字段显示为空，查看[创世区块](https://bitinfocharts.com/bitcoin/block/763148/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f) 。

### 2. 签名算法
指用于数字签名的算法。有三个作用：**防伪造，防篡改，防抵赖**  
1. 签名不可伪造，因为私钥只有签名人自己知道，所以其他人无法伪造签名。
2. 消息不可篡改，如果原始消息被人篡改了，那么对签名进行验证将失败。
3. 签名不可抵赖。如果对签名进行验证通过了，那么，该消息肯定是由签名人自己发出的，他不能抵赖自己曾经发过这一条消息。

签名算法一般采用**非对称加密算法**，它包含一套由**公钥和私钥**组成的密钥对，私钥由发送方保管，公钥可以公开。公私钥的作用是互补的，公钥加密则
私钥解密，私钥加密则公钥解密；  
在**加密场景**中的使用方式就是公钥加密，私钥解密；而**签名场景**中就是私钥加密，公钥解密。

>非对称加密算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC椭圆曲线加密算法

在签名场景中的**使用方法**：
1. 签名：发送方首先将明文消息进行哈希计算得到消息哈希值，然后使用**私钥加密**这个哈希值得到加密摘要（就是签名），把加密摘要（签名）和明文消息发给接收方
2. 验签：接收方使用事先发送方告知的**公钥解密**出消息哈希值，另外再使用提前已知的哈希算法对计算明文消息的哈希值，对比两个哈希值是否一致即可知道消息是否被篡改以及是否由发送方发送。
>签名过程也会用到哈希算法。

#### 2.1 比特币对签名算法的使用  
比特币中使用签名算法（ECDSA）来实现交易签名，同时也是一套账户方案。过程：用户用私钥对自己发起的交易进行签名，网络中的节点（矿工）使用同时**作为账户地址
的公钥**验证用户签发的交易数据是否有效/篡改；  
>通过私钥可以推出公钥，用户如果丢失私钥，则失去公钥账户下的所有资产。

比特币中用于签名的私钥本质上是一个256位的大整数，公钥则由私钥通过ECDSA算法计算出来的，且这个过程不能逆推，所以不必保存公钥。  
用银行卡作比较，公钥就是银行卡号，由两个256位整数（后会编码成一个地址），私钥就是密码（一个256位整数）。与银行卡不同的是，签名算法中，需要先确定
秘钥（密码），再算出公钥（卡号），所以无法修改【密码】，因为公私钥是一一对应的。  
**匿名性**  
由于比特币账本是全网公开的，所以，任何人都可以根据公钥查询余额，但是不知道拥有者是谁。这就是比特币的匿名特性。  
**无限账户**  
和银行账户不同，比特币网络没有账户的概念，任何人都可以从区块链查询到任意公钥对应的比特币余额，但是，并不知道这些公钥是由谁持有的，也就无法根据
用户查询比特币余额。作为用户，可以生成任意数量的私钥-公钥对，公钥是接收别人转账的地址，而私钥是花费比特币的唯一手段，**钱包程序**可以帮助用户
管理私钥-公钥对。  
**对私钥编码**
因为私钥是一位256位整数，太长无法被人类记住。因此，比特币有一种对私钥进行编码的方式，即带校验的Base58编码，而且有非压缩和压缩两种编码格式，也分别对应
非压缩和压缩的公钥格式。

**推导公钥**  
上面说过，根据ECDSA算法，可以对一个256整数的私钥推导出两个256位整数（公钥），记作（x,y），它们是**非压缩的公钥**。由于ECC曲线特点，根据非压缩
的公钥（x,y）的x也可以推算出y，但需要知道y的奇偶性，所以最终（x,y）就可以记录为x'，它作为**压缩的公钥**。  
压缩格式的公钥实际上只保存x这一个256位整数，但需要根据y的奇偶性在x前面添加02或03前缀，y为偶数时添加02，否则添加03，这样，得到一个1+32=33字节
的压缩格式的公钥数据，记作x'。注意压缩格式的公钥和非压缩格式的公钥是可以互相转换的，但均不可反向推导出私钥。非压缩格式的公钥目前已很少使用，
原因是非压缩格式的公钥签名脚本数据会更长。  

**比特币地址（即收款地址）**  
在早期的比特币系统中，都是直接使用公钥作为比特币地址收款的（P2PK，pay-to-pubkey），但由于后来证实ECDSA算法不安全，可以通过公钥破解私钥。
所以2010年就引入了一种新的交易类型P2PKH（pay-to-pubkey-hash），即使用将公钥通过哈希计算后得到的哈希值作为收款地址。  

以上，关于从私钥生成到推导公钥、生成比特币地址的详细过程可以参考本仓库的另一篇文章[比特币使用—比特币的公钥、私钥和「账户」地址](./bitcoin_usage.md#比特币的公钥私钥和账户地址) 。

## UTXO模型（Unspent Transaction Outputs）
它是比特币创新的一种账户余额模型（不同于常见系统中只记录某个账户的余额的方式），翻译为"未花费的交易输出"，下面进行解释。
#### 1. 每个区块中的每笔交易都由n(n≥0)个input和m（m≥1）个output（输入和输出）组成
首先，每个区块由区块头和区块体组成，区块头存放了比特币协议号、区块哈希、时间戳、上一区块哈希等字段信息；  
区块体则存放多笔交易信息，而每笔交易都由n(n≥0)个input和m（m≥1）个output（输入和输出）组成。  
- 输入（input）：0个或多个转账方比特币地址，以及转出比特币数量
- 输出（output）：1个或多个接受方比特币地址，每个地址对应一个转入比特币数量
- **每笔交易的输入之和 == 输出之和**

**请看下图**

<img src="./images/Transactions-input-and-output-in-blockchain.png" style="zoom: 80%">

#### 2.Coinbase
区块体中，第一笔交易叫做Coinbase（也可称铸币交易），它也是一笔特殊交易，因为其没有input（或者说以Coinbase为input），只有output就是矿工比特币地址以及得到的比特币奖励。  
每个区块都有Coinbase，这笔交易将使矿工比特币地址凭空增加比特币余额。
#### 3.UTXO交易过程
比如，我这个月打工挣了1w块，那么这笔交易的输入就是公司-1w，输出就是我+1w，这很简单；然后我要消费，比如买个电脑6k，剩余4k，在传统系统中，是我的
银行账户余额数字变成了4k，我后续的消费（交易）都是基于这个余额数字进行的，我也是通过银行账户直接查询我的余额，这很方便没问题；但是在比特币系统中，
没有类似银行账户的中央系统可查，那就说到这个UTXO模型，这个模型中，我上述2笔交易的记录是这样的：  
```
tx1： input：公司，1w，output：我，1w  （相当于我+1w）

tx2： input：我，1w  output-1：商场，6k （消费）
                    output-2:我，  4k （找零）
```
可以发现，现在我的余额可以这样计算：+1w - 1w + 4k = 4k，这其实就是关联我的多笔交易的输入输出合并后的结果。这里要注意一点，这个模型中不允许将
output拆开消费，比如tx1中针对我的output是1w，但我买电脑只需要6k，那我第二笔交易不可以只input 6k，必须从之前的交易中找到≥6k的output作为这次
交易的input，当然也可以合并多个之前的output作为这次的input（足够抵扣本次交易就行），简单说就是不能掰开花只能合并花。在tx2中可以看到，如果input
数字大于消费需要的output数字，那么抵扣消费后的数字会作为找零再形成兑付给我的output，这部分就叫做【**未花费的交易输出**】，等到这个output作为其他交易
的input之后，那它就不叫未花费的交易输出了！

**计算余额**  
在比特币网络中，每笔交易的每个输出都是一定数量的不可分割的比特币，这些输出由全网共同验证，并且可能被其持有者用做后续交易的输入。比特币全节点会
追踪和统计网络中所有可用的未交易输出，我们称这些交易输出为UTXO集合。当我们称一位用户拥有多少比特币时，实际上指的是比特币网络中有多少UTXO可以被该用户
控制的密钥使用。  
这些UTXO可能分散在成千上万的区块和交易中，比特币钱包帮我做收集和计算的工作，将这些UTXO总额以账户余额方式显示给用户。  
可以看到，UTXO模型完美适配比特币这种去中心化的货币系统。
>注意：交易输出可以是任意数量的Satoshi（比特币最小计量单位）；Coinbase只有输出，所以可以认为比特币网络是**先有输出**，再有输入的。

在任意时间点，现有 UTXO 的集合都被称为 UTXO 集。比特币节点会追踪 UTXO 集，从而确定哪些代币未被花费，以及哪些人可以花费它们。该系统可以让比特币
解决多重支付（Double Spend）问题。双重花费问题是长期困扰数字货币尝试的一大难题。

#### 4.UTXO 是如何创建的？  
新的 UTXO 是通过花费现有 UTXO 创建的。每个比特币交易都由输入和输出组成。输入花费已有 UTXO，输出则创建新的 UTXO。如果新的 UTXO 是通过销毁
已有 UTXO 创建的，那么最初的 UTXO 是怎么来的？  
显然就是Coinbase，每个UTXO的历史都可以追溯到 coinbase 交易的一个或多个输出。

#### 5.传统账户余额模型
这种模型更容易让人们理解，它就类似银行账户，银行系统直接存储了每个账户余额，交易时判断发起方余额是否足够。  
以太坊（Ethereum）就是使用账户余额模型的典型代表，它还区分了外部账户和智能合约账户，这里不做过多说明。

#### 6.UTXO与传统账户余额模型对比

1. 建模对象：用户交易是扣减分布在全网区块中与自己账户地址关联的未交易输出之和，也就是代币，所以UTXO对资产进行建模；余额模型对账户进行建模
2. 适用场景：UTXO不存在账户当前状态概念，可称它是无状态的，因此很难基于UTXO模型构建转账/货币发行等数字货币领域外的复杂应用，如智能合约；  
而余额模型就直接拥有账户余额状态等数据，可以进行丰富的编程应用。
3. 隐私性：UTXO模型为用户提供隐私优势。比特币用户可以将每个UTXO存储在不同的地址中分别处理。通过这种方式，用户可以隐藏其持有的 UTXO 之间的联系；
比特币的设计极大降低了生成新地址的难度。传统余额模型使得生成新账户变得非常麻烦，甚至不可行，迫使用户将全部或大部分资金存放在一个账户中。观察者可以
直接查询这个账户的交易流水以获得信息。

## 解决双花问题

这要提到几个关键词：**UTXO，区块时间戳，6次确认，分叉及最长链原则**

1. UTXO：当一个用户接收比特币时，金额被当作UTXO记录到区块链里。比特币系统当中记录着每一笔未花费的交易输出。当某一笔比特币交易被创建并广播到区块链网络之后，
接收到此交易信息的节点会对交易进行验证，需要去UTXO数据库里查，检查其是否存在于UTXO中。如果交易输出已不存在于UTXO中，则验证失败。
2. 区块时间戳：当一个用户同时将1个比特币同时转账给两人时，两笔交易仅会有一笔成功，因为矿工会选择记录优先接收到的，或者交付手续费更高的那笔交易。
当交易被矿工们先后记录到区块后，根据区块时间戳的大小来证明，最先被记录（时间戳小的）的交易才是有效的，其他记录了来自同一笔UTXO的交易的区块将被网络拒绝
（因为这一笔UTXO已经被全部花费了）。
3. 6次确认：是指在这当前区块之后又有5个区块被计算出来连接到区块链上，每一个都相当于对前面一个区块进行确认，区块链上每增加一个区块就增大了前面区块被篡改的难度，
6个之后就认为基本上没法被篡改，所以认为这笔交易就算完成了。
4. 分叉及最长链原则：因为同一时间段内全网不止一个节点能计算出随机数，也就是同时挖到了矿，这些节点都会把自己挖到的区块，链到自己本地的区块链上，
这就出现了区块链分叉，他们都会在网络广播他们各自打包好的区块，以便于其他节点同步完最新数据后，在最新的区块链上继续挖矿。由于同步需要时间，不同矿工看到的
这些区块是有先后顺序的，矿工会把先看到的区块复制过来，然后在该区块上继续开始新的挖矿工作。最终其中的一条链被证实为较长的一条，那么其他分支链条上工作
的节点将转换阵营，开始在较长的链条上工作，这条链就成了主链，其他分叉出来的链将会被网络抛弃、消失。

## 功能架构

### 1. 功能架构图

<img src="./images/bitcoin_feature_arch.jpg" height="316" width="810">

### 2. 区块链管理
主要包括同步区块、接收区块、验证区块以及发现最长链功能。在一个比特币全节点第一次加入比特币网络的时候，先要下载并验证整条区块链。随着时间推移，
比特币区块容量会不断增大，下载时间也会随之变长。2014年开始，区块链同步方式正式变成先从自己相邻节点下载区块头，相比一个1MB的完整区块，区块头只有80字节，
同步起来很快。 区块头同步完成后，节点就可以从不同节点同时更新不同区间的区块，大大提高整个区块链的同步速度。在同步过程中，节点会使用CheckPoint对特定区块hash进行验证。

### 3. 交易验证
临近节点收到交易后，会对交易信息进行一系列验证，验证通过后再广播至网络，无效交易在第一个节点处就会丢弃。

### 4. 交易内存池管理
节点将收到的合法交易放入本地内存池，准备放在一个区块中构成Merkle树进行挖矿。挖矿时，按照一定顺序从交易池中取出部分交易并打包进区块。
而顺序由交易输入和手续费共同决定。也就是说，存在时间越长的UTXO以及交易手续费越高的交易，越优先被打包。

挖矿成功后，将区块广播到网络中交给其他节点验证，同时从交易池中剔除已打包的交易。在发生分叉时，全节点会自动识别并同步最长链，同时将本地的较短链抛弃，重新在最长链上进行挖矿。

### 5. 邻节点管理
一个比特币节点启动时，需要去发现比特币网络中的节点，至少与一个节点相连才能正常使用。节点通过8333端口与一个已知节点建立TCP连接。发现新节点有两种方法：
1. 通过DNS种子。它是提供比特币地址的DNS服务器，在Bitcoin Core软件配置中自带了5个不同的种子。
2. 添加已知节点的IP。用户可以通过配置文件或控制台命令的方式添加已知节点的IP地址。

### 6. 共识管理
比特币是在P2P模式下运行的，因此共识的管理非常重要。目前比特币使用的是PoW算法。未来比特币社区会将共识模块从比特币核心中分离出去作为独立模块。

### 7. 规则管理
定义比特币所有节点都需要遵守的规则，只有遵守这些规则才能加入比特币网络正常运行。例如，比特币交易验证规则、区块验证规则等。

### 8. 密码模块
比特币系统中大量运用了密码学技术，主要用来处理比特币地址生成以及验证。使用了SHA256和RIPEMD160哈希算法，同时还有Base58Check编码。
这些算法的代码放在 [crypto](https://github.com/bitcoin/bitcoin/tree/master/src/crypto) 子目录下。

### 9. 签名模块
比特币采用的是椭圆曲线签名算法（ECDSA）来实现数字签名以及生成公钥，使用的曲线是secp256k1，因为该曲线具有比其他曲线更高的性能。
这部分代码放在 [secp256k1](https://github.com/bitcoin/bitcoin/tree/master/src/secp256k1) 子目录下。

### 10. 脚本引擎
虽然比特币的脚本语言非常小，只有256条指令，每条指令是1字节，常用的只有几条。但这可以说是最早版本的智能合约，为以太坊提供了解决思路。
以太坊虚拟机，就是比特币脚本的一个扩展，为其增加了图灵完备性。目前脚本部分代码放在 [script](https://github.com/bitcoin/bitcoin/tree/master/src/script) 子目录下。

### 11. 挖矿
在比特币的PoW算法中，挖矿是最核心的内容。其本质是全网矿工（任何具有一定算力的节点）进行双哈希运算的算力竞赛，争取记账权的一个过程。
起初，比特币最早的挖矿程序是通过CPU来挖矿的，但随着矿工节点的增加，很快CPU就不再具有优势，取而代之的是GPU成为挖矿主力。随着比特币价值进一步提高，
更专业的FPGA、ASIC等专业设备相继出现。新旧更迭，目前市场上的矿机均是清一色的ASIC组成的矿池。

### 12. HTTP/JSON RPC服务端
比特币节点启动时，初始化程序init.cpp会启动HTTP/JSON RPC服务端，该组件对外提供了JSON RPC接口，外部程序可以通过接口控制比特币节点。但远程连接比特币节点有极大风险，一般不推荐使用。

### 13. 数据库
比特币系统采用的数据库有BerkeleyDB和LevelDB，二者均是非关系型数据库。其中比特币钱包使用的是BerkeleyDB，而LevelDB用在存储区块索引和UTXO记录。
区块原始数据则以dat文件形式存储在本地，非数据库存储。

### 14. ZeroMQ
比特币采用ZeroMQ作为消息队列管理和消息分发的工具。它是一种基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、路由的底层细节进行抽象，
提供跨越多种传输协议的套接字。

## 系统架构
比特币系统是区块链1.0的典型应用，是第一个去中心化的数字货币系统。一般来说，区块链1.0数字货币系统系统架构分5层，如下图

### 1. 系统架构图
<img src="./images/bitcoin_sys_arch.jpg" height="298" width="714">

### 2. 数据层
以密码学为基础构建的以区块为单位的链状数据结构。其中每个区块都需要包括前一个区块的哈希值，当前时间戳以及最近一段时间的交易信息等内容。
由于每个区块都是与前续区块通过密码学证明的方式链接在一起的，当区块链达到一定长度后，要修改某个历史区块中的交易就必须将该区块之后所有的区块及密码学证明进行重构，
这已经被证实为实际不可能（或者说极低概率）发生的事件。因为比特币使用的PoW共识算法以及最长链原则要求攻击者具有全网51%算力才能成功替换现有主链，随着比特币系统的逐渐发展，目前其节点已遍布全球，
所以想要拥有51%的算力在实际上已经不太可能，即使存在可能，那么攻击者为获得高算力资源而付出的成本已经超出了攻击获利。并且当发生如此重量级的攻击事件后，
比特币的价值必然暴跌，到头来损失最惨重的还是攻击者。

### 3. 网络层

TODO
---

参考
- [《区块链技术开发指南-马兆丰》](https://baike.baidu.com/item/区块链技术开发指南/56688853?fr=aladdin)
- [《精通比特币》](https://www.oreilly.com/library/view/mastering-bitcoin/9781491902639/ch05.html)
- [比特币区块链哈希树(MerkleRoot)的计算方法](https://www.exchen.net/bitcoin-blockchain-merkleroot.html)
- [Calculating merkle root and merkle proof in Bitcoin](https://ashutosh-tripathi.medium.com/calculating-merkle-root-and-proof-of-inclusion-in-bitcoin-ebd65f504af9)