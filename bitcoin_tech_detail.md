## 比特币系统设计

比特币的底层网络协议是p2p网络，不依赖于任何一个单一的服务器，而且比特币的源代码是开源的，由比特币社区共同去维护的。

比特币不受任何一个单一组织的控制，开发者，矿工，交易所，用户共同组成比特币社区，相互协调维护比特币的发展。比特币的运行依赖于
比特币的每一个节点，但是单一节点运行失败并不影响整个比特币网络。

1. 分布式账本（区块链）：首先，交易信息需要存储，没有了中心机构，比特币将它存储在全网所有加入比特币网络的节点之上，这叫做分布式账本。它是以N个区块链接起来的形式工作的，
每个区块相当于一个小账本，记录了多笔交易信息和上一个区块的地址。
2. 工作量证明（Proof of work，记账权）：如何保证每个账本的一致性成了一个问题，比如A本来只有1元，在两个节点的记录结果却不同可不行。比特币引入记账权的概念，网络中的节点若要想要获得
记账的权利， 就必须完成一道系统提供的数学题（耗费一定的算力和时间进行一项哈希计算工作，直到算出一个满足条件的结果结束）。谁做得快就就优先获得记账权。
这也叫做工作量证明，它是区块链账本的安全机制。
3. 最长链原则：传统交易基于中心机构进行，没有双花（双重支付）问题，但区块链架构之上该如何解决？那就是最长链原则。同一笔钱的第二次以上的交易一定是无效的，
并且第一次和第二次交易不可能存在于同一个链条中（把同一个链条看做一个中心账本），所以第二次交易所在区块（账本）一定是从主链上分叉出去的，这就导致
链条分叉，从上面得知想要记账先要获得记账权，就得有很高的算力，因为比特币系统中任意节点都可以来竞争记账权，显然主链增加的速度一定是极快的，分叉的链条
就一定很慢，因为只有攻击者独自维护分叉链条，这就变成了一场算力比拼，显然攻击者的算力无法与全网算力竞争，最终就只有主链被系统承认。

### 四个关键设计

- p2p网络技术
- 分布式账本（区块-链）
- 工作量证明共识机制
- 最长链原则

### 分布式账本（区块链）
#### 账本（区块）是如何链接的？
整个账本（一条区块链）由一串使用密码学算法产生的区块（单个账本）连接而成。每一个区块上写满了交易记录，区块按顺序相连形成链状结构，也就是区块链大账本。  
矿工在生成新区块时，需要根据前一个区块的唯一哈希值（叫做区块哈希）、新交易区块和随机数，来计算新的区块哈希和随机数。也就是说每一个
区块都是在前一个区块数据的基础上生成的，该机制保证了区块链数据的唯一性。  
区块中的主要数据就是一系列交易，第一条交易通常是Coinbase交易，也就是矿工的挖矿奖励，后续交易都是用户的交易。

### 比特币分叉

指的是区块链条的分叉，又分为硬分叉和软分叉。  
为什么会分叉？  
因为比特币系统中的1个区块大小为1MB，区块限制了容纳交易的笔数。比特币对单笔交易的大小没有限制，一般来说一笔交易的大小为250B，所以一个区块大约
能容纳4000多笔交易，然后比特币系统规定10分钟产生一个新区块，通过计算得知比特币系统的每秒可交易笔数 4000/600≈7笔。显然，对于全球用户来说，
这个速度可太慢了，所以人们就想到了对比特币区块扩容，这就要修改比特币软件代码了。

#### 什么是分叉？

软件由于**方案优化、BUG修复**等原因进行升级是一种非常常见的现象。如手机应用等传统软件，升级非常简单，只需厂商发布，用户接 受升级即可。  
但是对于比特币这种去中心化的系统，升级是非常困难 的，需要协调网络中每个参与者。软件升级意味着运行逻辑的改变， 但是在比特币中，
升级必然会导致不同节点在一定时间内运行不同的版本，于是就会产生分叉。

分叉主要包含软分叉和硬分叉两种。如果比特币升级后，新的代 码逻辑向前兼容，即新规则产生的区块仍然会被旧节点接受，则为软分叉；
如果新的代码逻辑无法向前兼容，即新产生的规则产生的区块无法被旧节点接受，则为硬分叉。

#### 1.硬分叉
比如对区块大小扩容从1M到4M，升级后的节点产生的4M区块广播到网络中，那些旧节点会认为这个区块是非法的，不认可。旧节点仍然会基于原来的1M区块
的链条继续产生新区块。如此新旧节点不兼容就导致主链分叉，产生第二条链。  
>注意：新节点会认可旧节点产生的区块

这种分叉是永久性的，只要旧节点不更新软件，原先的主链就不会消失，并且无法合并两条链，这就叫做硬分叉。
>2018年，区块的扩容导致最初的比特币主链分叉出新的链条，形成了现在的**BitCash**，一个新的基于区块链的加密货币；旧链条仍然是比特币。
> 在BCH之后，又发生了多个分叉。理论上，任何参与比特币网络的节点（矿工）都可以分叉。

#### 2.软分叉
同样是比特币协议发生了部分变化，但旧节点仍然能接受新节点产生（挖出）的区块，并基于新区块继续添加旧区块。  
软分叉由于向前兼容，新旧节点仍然运行在同一条区块链上，并不会产生两条链，对整个系统影响相对较小。  
到目前为止，比特币发生过多次软分叉，如BIP-34，BIP-65，BIP-66，BIP-9等。其中比特币改进建议（Bitcoin Improvement Proposal, BIP）
指的是比特币社区成员针对比特币提出的一系列改进建议。
>软分叉虽然对系统的影响较小，但是为了保证向前兼容，不能新增字段，只能在现有数据结构下修改，即可升级的内容非常有限。  
> 同时，因为这些限制，软分叉一般升级方案比较复杂，复杂的方案往往更容易产生BUG，并且可维护性很差。

### 一些通用概念

#### 矿工和挖矿
指的是参与到比特币网络中不停消耗算力去试图把新的交易打包成新区块的节点，这个尝试打包的过程就是挖矿；它们的动力来自于产生新区块而获得的比特币奖励

#### 挖矿过程(原理)
比特币挖矿的逻辑过程如下：
1. 打包交易，检索待确认交易内存池，选择包含进区块的交易。矿工可以任意选择，甚至可以不选择(挖空块)，因为每一个区块有容量限制(当前是1M)，所以矿工
也不能无限选择。对于矿工来说，最合理的策略是首先根据手续费对待确认交易集进行排序，然后由高到低尽量纳入最多的交易。
2. 构造Coinbase，确定了包含进区块的交易集后，就可以统计本区块手续费总额，结合产出规则，矿工可以计算自己本区块的收益。
3. 构造hashMerkleRoot，对所有交易构造Merkle数。
4. 填充其他字段，获得完整区块头。
5. Hash运算，对区块头进行SHA256D运算。
6. 验证结果，如果符合难度，则广播到全网，挖下一个块;不符合难度则根据一定策略改变以上某个字段后再进行Hash运算并验证。
>Coinbase是什么：每个区块都会包含至少一个交易，第一笔交易就叫做coinbase，每笔交易都包含了input和output，正常交易的input是转账来源方的钱包地址，
> output就是接收方的地址；而coinbase的input没有任何地址，只有output记录了给与矿工打包区块成功的奖励和手续费。Coinbase是一笔特殊交易。

这个算法也叫做**POW**（Proof Of Work）。  
合格的区块条件： **SHA256D(BlockHeader) < F(nBits)**  
其中，SHA256D(BlockHeader)就是挖矿结果，F(nBits)是难度对应的目标值，两者都是256位，都当成大整数处理，直接对比大小以判断是否符合难度要求。

#### 不断的计算哈希值（挖矿）
比特币系统规定，打包产生的新区块的区块哈希值，必须小于给定的难度哈希值，这个区块才算有效。
区块哈希的大致计算方式：block_hash=Sha256D(BlockHeader)，而区块头包含了nVersion，hashPrevBlock, hashMerkleRoot, nTIme, nBits, nNonce这些字段；  

其中nVersion是比特币协议号，一般不会变化，hashPrevBlock是前一个有效区块的区块哈希，nBits由全网决定，每2016个区块重新调整，调整算法固定。
因此这三个字段可以认为是固定的，对于每个矿工都是一样，而矿工可以自由调整的是剩下三个字段：hashMerkleRoot,nTime,nNonce；  
其中nTime提供的修改空间非常有限，因为有效的区块时间由一个范围，范围由前一个区块决定，比前一个区块时间太早或者太延后都会被其他节点拒绝。
一般来说，矿工会直接使用机器当前时间戳。  
nNonce，提供2^32种可能取值；  
hashMerkleRoot，理论上提供2^256种可能，本字段的变化来自于对包含进区块的交易进行增删，或改变顺序，或者修改Coinbase交易的输入字段。 

在CPU挖矿时代，修改空间主要由nNonce提供，也就是不断的累加nNonce值然后进行哈希计算，然后判断哈希值是否小于难度值，循环往复。进入矿机时代，
nNonce提供的4个字节已经远远不够，搜索空间转向hashMerkleRoot。

#### 动态调整的难度哈希
比特币网络的难度是不断变化的，它的难度保证大约每10分钟产生一个区块，而难度值在每2015个区块调整一次：如果区块平均生成时间小于10分钟，
说明全网算力增加，难度也会增加，如果区块平均生成时间大于10分钟，说明全网算力减少，难度也会减少。因此，难度随着全网算力的增减会动态调整。

所以比特币的工作量证明被通俗地称之为挖矿。在同一时间，所有矿工都在努力计算下一个区块的哈希。而挖矿难度取决于全网总算力的百分比。  
比特币挖矿已经从早期的CPU、GPU发展到专用的ASIC芯片构建的矿池挖矿。
>比特币设计时本来打算每2016个区块调整一次难度，也就是两周一次，但是由于第一版代码的一个bug，实际调整周期是2015个区块。


### 采用的加密算法

主要采用了**哈希算法**（SHA-256和RipeMD160）用于计算单个区块的唯一哈希值，保证区块无法被篡改，因为一段篡改，哈希值将改变，哈希验证无法通过，则
说明此区块无效；  
采用了**非对称加密算法**（ECDSA）用于数字签名。

#### 哈希算法
又称散列算法、摘要/单向加密算法。具有不可逆推性，它把任意长度的字节输入转换为固定长度的输出。  
一个优秀的哈希算法需要满足较低碰撞率。  
**比特币区块链中的Merkle Hash**：在区块的头部，有一个Merkle Hash字段，它记录了本区块所有交易的Merkle Hash，Merkle Hash是把一系列数据的哈希根据一个简单算法变成一个汇总
的哈希。在每一层计算中，如果是偶数个交易哈希，每两个交易哈希通过dhash（）合成一个，如果有单数，就把最后一份数据复制，再合成，
不断进行金字塔式合成，最后一定能计算出Merkle Hash。从Merkle Hash的计算方法可以得出结论：**修改任意一个交易哪怕一个字节，或者
交换两个交易的顺序，都会导致Merkle Hash验证失败**，也就会导致这个区块本身是无效的，所以，Merkle Hash记录在区块头部，它的作用
就是保证交易记录永远无法修改。  
**比特币区块链中的Block Hash**：也就是区块哈希来标识。但是，一个区块自己的区块哈希并没有记录在区块头部，而是通过计算区块头部的哈希得到的。
区块头部的Prev Hash记录了上一个区块的Block Hash，这样，可以通过Prev Hash追踪到上一个区块。由于下一个区块的Prev Hash又会指向当前区块，
这样，每个区块的Prev Hash都指向自己的上一个区块，这些区块串起来就形成了区块链。区块链的第一个区块（又称创世区块）并没有上一个区块，因此，
它的Prev Hash被设置为00000000...000。

#### 签名算法
指用于数字签名的算法。有三个作用：**防伪造，防篡改，防抵赖**  
1. 签名不可伪造，因为私钥只有签名人自己知道，所以其他人无法伪造签名。
2. 消息不可篡改，如果原始消息被人篡改了，那么对签名进行验证将失败。
3. 签名不可抵赖。如果对签名进行验证通过了，那么，该消息肯定是由签名人自己发出的，他不能抵赖自己曾经发过这一条消息。

签名算法一般采用**非对称加密算法**，它包含一套由**公钥和私钥**组成的密钥对，私钥由发送方保管，公钥可以公开。公私钥的作用是互补的，公钥加密则
私钥解密，私钥加密则公钥解密；  
在**加密场景**中的使用方式就是公钥加密，私钥解密；而**签名场景**中就是私钥加密，公钥解密。

>非对称加密算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC椭圆曲线加密算法

在签名场景中的**使用方法**：
1. 签名：发送方首先将明文消息进行哈希计算得到消息哈希值，然后使用**私钥加密**这个哈希值得到加密摘要（就是签名），把加密摘要（签名）和明文消息发给接收方
2. 验签：接收方使用事先发送方告知的**公钥解密**出消息哈希值，另外再使用提前已知的哈希算法对计算明文消息的哈希值，对比两个哈希值是否一致即可知道消息是否被篡改以及是否由发送方发送。
>签名过程也会用到哈希算法。

**比特币系统对签名算法的使用**：  
比特币中使用签名算法（ECDSA）来实现交易签名，同时也是一套账户方案。过程：用户用私钥对自己发起的交易进行签名，网络中的节点（矿工）使用同时**作为账户地址
的公钥**验证用户签发的交易数据是否有效/篡改；  
>通过私钥可以推出公钥，用户如果丢失私钥，则失去公钥账户下的所有资产。

比特币中用于签名的私钥本质上是一个256位的整数，公钥则由私钥通过ECDSA算法计算出来的，且这个过程不能逆推，所以不必保存公钥。  
用银行卡作比较，公钥就是银行卡号，由两个256位整数（后会编码成一个地址），私钥就是密码（一个256位整数）。与银行卡不同的是，签名算法中，需要先确定
秘钥（密码），再算出公钥（卡号），所以无法修改【密码】，因为是公私钥一一对应的。  
**匿名性**  
由于比特币账本是全网公开的，所以，任何人都可以根据公钥查询余额，但是，不知道持卡人是谁。这就是比特币的匿名特性。  
**无限账户**  
和银行账户不同，比特币网络没有账户的概念，任何人都可以从区块链查询到任意公钥对应的比特币余额，但是，并不知道这些公钥是由谁持有的，也就无法根据
用户查询比特币余额。作为用户，可以生成任意数量的私钥-公钥对，公钥是接收别人转账的地址，而私钥是花费比特币的唯一手段，**钱包程序**可以帮助用户
管理私钥-公钥对。  
**对私钥编码**
因为私钥是一位256位整数，太长无法被人类记住。因此，比特币有一种对私钥进行编码的方式，即带校验的Base58编码，而且有非压缩和压缩两种编码格式，也分别对应
非压缩和压缩的公钥格式。  
1. 非压缩编码过程：在32字节的私钥前添加一个0x80字节前缀，得到33字节的数据，对其计算4字节的校验码，附加到最后，一共得到37字节的数据。计算校验码非常简单，
对其进行两次SHA256，取开头4字节作为校验码。最后对这37字节的数据进行Base58编码，得到总是以5开头的字符串，它就是我们要小心保存的私钥地址，又称为
钱包导入格式（WIF: wallet import format）。  
2. 压缩编码过程：在32字节的私钥前后各添加一个0x80字节前缀和0x01字节后缀，共34字节的数据，对其计算4字节的校验码，附加到最后，一共得到38字节的数据。
**目前，非压缩的格式几乎已经不使用了**。
> 使用非压缩格式的WIF是以5开头的字符串，使用压缩格式的WIF是以K或L开头的字符串，这个字符串就是需要私密保存的**私钥地址**。  

**推导公钥**  
上面说过，根据ECDSA算法，可以对一个256整数的私钥推导出两个256位整数（公钥），记作（x,y），它们是**非压缩的公钥**。由于ECC曲线特点，根据非压缩
的公钥（x,y）的x也可以推算出y，但需要知道y的奇偶性，所以最终（x,y）就可以记录为x'，它作为**压缩的公钥**。  
压缩格式的公钥实际上只保存x这一个256位整数，但需要根据y的奇偶性在x前面添加02或03前缀，y为偶数时添加02，否则添加03，这样，得到一个1+32=33字节
的压缩格式的公钥数据，记作x'。注意压缩格式的公钥和非压缩格式的公钥是可以互相转换的，但均不可反向推导出私钥。非压缩格式的公钥目前已很少使用，
原因是非压缩格式的公钥签名脚本数据会更长。  
**公钥哈希作为比特币钱包地址**  
要特别注意，比特币的地址并不是公钥，而是公钥的哈希。  
以压缩格式的公钥为例，从公钥计算地址的方法是，首先对1+32=33字节的公钥数据进行Hash160（即先计算SHA256，再计算RipeMD160），得到20字节的哈希。
然后，添加0x00前缀，得到1+20=21字节数据，再计算4字节校验码，拼在一起，总计得到1+20+4=25字节数据。对上述25字节数据进行Base58编码，得到总是
以1开头的字符串，该字符串即为比特币地址，可以安全地公开给任何人。
>注意：对非压缩格式的公钥和压缩格式的公钥进行哈希编码得到的地址，都是以1开头的，因此，从地址本身并无法区分出使用的是压缩格式还是非压缩格式的公钥。


### UTXO模型（Unspent Transaction Outputs）

比特币账本只会记录交易，而不关心"地址"，如果需要知道地址上面有多少余额，就需要找到该地址上面的 UTXO，计算出其余额，这就是钱包的功能。

### 数字钱包

待记录