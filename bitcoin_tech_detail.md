# 比特币技术细节

### 目录
TODO

比特币的底层网络协议是p2p网络，不依赖于任何一个单一的服务器，而且比特币的源代码是开源的，由比特币社区共同去维护的。

比特币不受任何一个单一组织的控制，开发者，矿工，交易所，用户共同组成比特币社区，相互协调维护比特币的发展。比特币的运行依赖于
比特币的每一个节点，但是单一节点运行失败并不影响整个比特币网络。

## 四个关键设计

- p2p网络技术
- 分布式账本（区块-链）
- 工作量证明共识机制
- 最长链原则

1. p2p网络技术：TODO
2. 分布式账本（区块链）：首先，交易信息需要存储，没有了中心机构，比特币将它存储在全网所有加入比特币网络的节点之上，这叫做分布式账本。它是以N个区块链接起来的形式工作的，
   每个区块相当于一个小账本，记录了多笔交易信息和上一个区块的地址。
3. 工作量证明（Proof of work，记账权）：如何保证每个账本的一致性成了一个问题，比如A本来只有1元，在两个节点的记录结果却不同可不行。比特币引入记账权的概念，网络中的节点若要想要获得
   记账的权利， 就必须完成一道系统提供的数学题（耗费一定的算力和时间进行一项哈希计算工作，直到算出一个满足条件的结果结束）。谁做得快就就优先获得记账权。
   这也叫做工作量证明，它是区块链账本的安全机制。
4. 最长链原则：传统交易基于中心机构进行，没有双花（双重支付）问题，但区块链架构之上该如何解决？那就是最长链原则。同一笔钱的第二次以上的交易一定是无效的，
   并且第一次和第二次交易不可能存在于同一个链条中（把同一个链条看做一个中心账本），所以第二次交易所在区块（账本）一定是从主链上分叉出去的，这就导致
   链条分叉，从上面得知想要记账先要获得记账权，就得有很高的算力，因为比特币系统中任意节点都可以来竞争记账权，显然主链增加的速度一定是极快的，分叉的链条
   就一定很慢，因为只有攻击者独自维护分叉链条，这就变成了一场算力比拼，显然攻击者的算力无法与全网算力竞争，最终就只有主链被系统承认。


## 分布式账本（区块链）

#### 账本（区块）是如何链接的？
整个账本（一条区块链）由一串使用密码学算法产生的区块（单个账本）连接而成。每一个区块上写满了交易记录，区块按顺序相连形成链状结构，也就是区块链大账本。  
矿工在生成新区块时，需要根据前一个区块的唯一哈希值（叫做区块哈希）、新交易区块和随机数，来计算新的区块哈希和随机数。也就是说每一个
区块都是在前一个区块数据的基础上生成的，该机制保证了区块链数据的唯一性。  
区块中的主要数据就是一系列交易，第一条交易通常是Coinbase交易，也就是矿工的挖矿奖励，后续交易都是用户的交易。

**下图展示区块的大致组成和链接方式**

图一  
![](./images/The-structure-of-a-Blockchain-A-block-is-composed-of-a-header-and-a-body-where-a-header.png)


图二  
<img src="./images/bitcoin_block_detail.jpg" style="zoom: 80%">

## 比特币分叉

指的是区块链条的分叉，又分为硬分叉和软分叉。  
为什么会分叉？  
因为比特币系统中的1个区块大小为1MB，区块限制了容纳交易的笔数。比特币对单笔交易的大小没有限制，一般来说一笔交易的大小为250B，所以一个区块大约
能容纳4000多笔交易，然后比特币系统规定10分钟产生一个新区块，通过计算得知比特币系统的每秒可交易笔数 4000/600≈7笔。显然，对于全球用户来说，
这个速度可太慢了，所以人们就想到了对比特币区块扩容，这就要修改比特币软件代码了。

#### 什么是分叉？

软件由于**方案优化、BUG修复**等原因进行升级是一种非常常见的现象。如手机应用等传统软件，升级非常简单，只需厂商发布，用户接 受升级即可。  
但是对于比特币这种去中心化的系统，升级是非常困难 的，需要协调网络中每个参与者。软件升级意味着运行逻辑的改变， 但是在比特币中，
升级必然会导致不同节点在一定时间内运行不同的版本，于是就会产生分叉。

分叉主要包含软分叉和硬分叉两种。如果比特币升级后，新的代 码逻辑向前兼容，即新规则产生的区块仍然会被旧节点接受，则为软分叉；
如果新的代码逻辑无法向前兼容，即新产生的规则产生的区块无法被旧节点接受，则为硬分叉。

#### 1.硬分叉
比如对区块大小扩容从1M到4M，升级后的节点产生的4M区块广播到网络中，那些旧节点会认为这个区块是非法的，不认可。旧节点仍然会基于原来的1M区块
的链条继续产生新区块。如此新旧节点不兼容就导致主链分叉，产生第二条链。  
>注意：新节点会认可旧节点产生的区块

这种分叉是永久性的，只要旧节点不更新软件，原先的主链就不会消失，并且无法合并两条链，这就叫做硬分叉。
>2018年，区块的扩容导致最初的比特币主链分叉出新的链条，形成了现在的**BitCash**，一个新的基于区块链的加密货币；旧链条仍然是比特币。
> 在BCH之后，又发生了多个分叉。理论上，任何参与比特币网络的节点（矿工）都可以分叉。

#### 2.软分叉
同样是比特币协议发生了部分变化，但旧节点仍然能接受新节点产生（挖出）的区块，并基于新区块继续添加旧区块。  
软分叉由于向前兼容，新旧节点仍然运行在同一条区块链上，并不会产生两条链，对整个系统影响相对较小。  
到目前为止，比特币发生过多次软分叉，如BIP-34，BIP-65，BIP-66，BIP-9等。其中比特币改进建议（Bitcoin Improvement Proposal, BIP）
指的是比特币社区成员针对比特币提出的一系列改进建议。
>软分叉虽然对系统的影响较小，但是为了保证向前兼容，不能新增字段，只能在现有数据结构下修改，即可升级的内容非常有限。  
> 同时，因为这些限制，软分叉一般升级方案比较复杂，复杂的方案往往更容易产生BUG，并且可维护性很差。

## 一些通用概念

#### 矿工和挖矿
指的是参与到比特币网络中不停消耗算力去试图把新的交易打包成新区块的节点，这个尝试打包的过程就是挖矿；它们的动力来自于产生新区块而获得的比特币奖励

#### 挖矿过程(原理)
比特币挖矿的逻辑过程如下：
1. 打包交易，检索待确认交易内存池，选择包含进区块的交易。矿工可以任意选择，甚至可以不选择(挖空块)，因为每一个区块有容量限制(当前是1M)，所以矿工
也不能无限选择。对于矿工来说，最合理的策略是首先根据手续费对待确认交易集进行排序，然后由高到低尽量纳入最多的交易。
2. 构造Coinbase，确定了包含进区块的交易集后，就可以统计本区块手续费总额，结合产出规则，矿工可以计算自己本区块的收益。
3. 构造hashMerkleRoot，对所有交易构造Merkle数。
4. 填充其他字段，获得完整区块头。
5. Hash运算，对区块头进行SHA256D运算。
6. 验证结果，如果符合难度，则广播到全网，挖下一个块;不符合难度则根据一定策略改变以上某个字段后再进行Hash运算并验证。
>Coinbase是什么：每个区块都会包含至少一个交易，第一笔交易就叫做coinbase，每笔交易都包含了input和output，正常交易的input是转账来源方的钱包地址，
> output就是接收方的地址；而coinbase的input没有任何地址，只有output记录了给与矿工打包区块成功的奖励和手续费。Coinbase是一笔特殊交易。

这个算法也叫做**POW**（Proof Of Work）。  
合格的区块条件： **SHA256D(BlockHeader) < F(nBits)**  
其中，SHA256D(BlockHeader)就是挖矿结果，F(nBits)是难度对应的目标值，两者都是256位，都当成大整数处理，直接对比大小以判断是否符合难度要求。

#### 不断的计算哈希值（挖矿）
比特币系统规定，打包产生的新区块的区块哈希值，必须小于给定的难度哈希值，这个区块才算有效。
区块哈希的大致计算方式：block_hash=Sha256D(BlockHeader)，而区块头包含了nVersion，hashPrevBlock, hashMerkleRoot, nTIme, nBits, nNonce这些字段；  

其中nVersion是比特币协议号，一般不会变化，hashPrevBlock是前一个有效区块的区块哈希，nBits由全网决定，每2016个区块重新调整，调整算法固定。
因此这三个字段可以认为是固定的，对于每个矿工都是一样，而矿工可以自由调整的是剩下三个字段：hashMerkleRoot,nTime,nNonce；  
其中nTime提供的修改空间非常有限，因为有效的区块时间由一个范围，范围由前一个区块决定，比前一个区块时间太早或者太延后都会被其他节点拒绝。
一般来说，矿工会直接使用机器当前时间戳。  
nNonce，提供2^32种可能取值；  
hashMerkleRoot，理论上提供2^256种可能，本字段的变化来自于对包含进区块的交易进行增删，或改变顺序，或者修改Coinbase交易的输入字段。 

在CPU挖矿时代，修改空间主要由nNonce提供，也就是不断的累加nNonce值然后进行哈希计算，然后判断哈希值是否小于难度值，循环往复。进入矿机时代，
nNonce提供的4个字节已经远远不够，搜索空间转向hashMerkleRoot。

#### 动态调整的难度哈希
比特币网络的难度是不断变化的，它的难度保证大约每10分钟产生一个区块，而难度值在每2015个区块调整一次：如果区块平均生成时间小于10分钟，
说明全网算力增加，难度也会增加，如果区块平均生成时间大于10分钟，说明全网算力减少，难度也会减少。因此，难度随着全网算力的增减会动态调整。

所以比特币的工作量证明被通俗地称之为挖矿。在同一时间，所有矿工都在努力计算下一个区块的哈希。而挖矿难度取决于全网总算力的百分比。  
比特币挖矿已经从早期的CPU、GPU发展到专用的ASIC芯片构建的矿池挖矿。
>比特币设计时本来打算每2016个区块调整一次难度，也就是两周一次，但是由于第一版代码的一个bug，实际调整周期是2015个区块。


## 采用的加密算法

主要采用了**哈希算法**（SHA-256和RipeMD160）用于计算单个区块的唯一哈希值，保证区块无法被篡改，因为一段篡改，哈希值将改变，哈希验证无法通过，则
说明此区块无效；  
采用了**非对称加密算法**（ECDSA）用于数字签名。

#### 哈希算法
又称散列算法、摘要/单向加密算法。具有不可逆推性，它把任意长度的字节输入转换为固定长度的输出。  
一个优秀的哈希算法需要满足较低碰撞率。  
**比特币区块链中的Merkle Hash**：在区块的头部，有一个Merkle Hash字段，它记录了本区块所有交易的Merkle Hash，Merkle Hash是把一系列数据的哈希根据一个简单算法变成一个汇总
的哈希。在每一层计算中，如果是偶数个交易哈希，每两个交易哈希通过dhash（）合成一个，如果有单数，就把最后一份数据复制，再合成，
不断进行金字塔式合成，最后一定能计算出Merkle Hash。从Merkle Hash的计算方法可以得出结论：**修改任意一个交易哪怕一个字节，或者
交换两个交易的顺序，都会导致Merkle Hash验证失败**，也就会导致这个区块本身是无效的，所以，Merkle Hash记录在区块头部，它的作用
就是保证交易记录永远无法修改。  
**比特币区块链中的Block Hash**：也就是区块哈希来标识。但是，一个区块自己的区块哈希并没有记录在区块头部，而是通过计算区块头部的哈希得到的。
区块头部的Prev Hash记录了上一个区块的Block Hash，这样，可以通过Prev Hash追踪到上一个区块。由于下一个区块的Prev Hash又会指向当前区块，
这样，每个区块的Prev Hash都指向自己的上一个区块，这些区块串起来就形成了区块链。区块链的第一个区块（又称创世区块）并没有上一个区块，因此，
它的Prev Hash被设置为00000000...000。

#### 签名算法
指用于数字签名的算法。有三个作用：**防伪造，防篡改，防抵赖**  
1. 签名不可伪造，因为私钥只有签名人自己知道，所以其他人无法伪造签名。
2. 消息不可篡改，如果原始消息被人篡改了，那么对签名进行验证将失败。
3. 签名不可抵赖。如果对签名进行验证通过了，那么，该消息肯定是由签名人自己发出的，他不能抵赖自己曾经发过这一条消息。

签名算法一般采用**非对称加密算法**，它包含一套由**公钥和私钥**组成的密钥对，私钥由发送方保管，公钥可以公开。公私钥的作用是互补的，公钥加密则
私钥解密，私钥加密则公钥解密；  
在**加密场景**中的使用方式就是公钥加密，私钥解密；而**签名场景**中就是私钥加密，公钥解密。

>非对称加密算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC椭圆曲线加密算法

在签名场景中的**使用方法**：
1. 签名：发送方首先将明文消息进行哈希计算得到消息哈希值，然后使用**私钥加密**这个哈希值得到加密摘要（就是签名），把加密摘要（签名）和明文消息发给接收方
2. 验签：接收方使用事先发送方告知的**公钥解密**出消息哈希值，另外再使用提前已知的哈希算法对计算明文消息的哈希值，对比两个哈希值是否一致即可知道消息是否被篡改以及是否由发送方发送。
>签名过程也会用到哈希算法。

**比特币系统对签名算法的使用**：  
比特币中使用签名算法（ECDSA）来实现交易签名，同时也是一套账户方案。过程：用户用私钥对自己发起的交易进行签名，网络中的节点（矿工）使用同时**作为账户地址
的公钥**验证用户签发的交易数据是否有效/篡改；  
>通过私钥可以推出公钥，用户如果丢失私钥，则失去公钥账户下的所有资产。

比特币中用于签名的私钥本质上是一个256位的整数，公钥则由私钥通过ECDSA算法计算出来的，且这个过程不能逆推，所以不必保存公钥。  
用银行卡作比较，公钥就是银行卡号，由两个256位整数（后会编码成一个地址），私钥就是密码（一个256位整数）。与银行卡不同的是，签名算法中，需要先确定
秘钥（密码），再算出公钥（卡号），所以无法修改【密码】，因为是公私钥一一对应的。  
**匿名性**  
由于比特币账本是全网公开的，所以，任何人都可以根据公钥查询余额，但是，不知道持卡人是谁。这就是比特币的匿名特性。  
**无限账户**  
和银行账户不同，比特币网络没有账户的概念，任何人都可以从区块链查询到任意公钥对应的比特币余额，但是，并不知道这些公钥是由谁持有的，也就无法根据
用户查询比特币余额。作为用户，可以生成任意数量的私钥-公钥对，公钥是接收别人转账的地址，而私钥是花费比特币的唯一手段，**钱包程序**可以帮助用户
管理私钥-公钥对。  
**对私钥编码**
因为私钥是一位256位整数，太长无法被人类记住。因此，比特币有一种对私钥进行编码的方式，即带校验的Base58编码，而且有非压缩和压缩两种编码格式，也分别对应
非压缩和压缩的公钥格式。  
1. 非压缩编码过程：在32字节的私钥前添加一个0x80字节前缀，得到33字节的数据，对其计算4字节的校验码，附加到最后，一共得到37字节的数据。计算校验码非常简单，
对其进行两次SHA256，取开头4字节作为校验码。最后对这37字节的数据进行Base58编码，得到总是以5开头的字符串，它就是我们要小心保存的私钥地址，又称为
钱包导入格式（WIF: wallet import format）。  
2. 压缩编码过程：在32字节的私钥前后各添加一个0x80字节前缀和0x01字节后缀，共34字节的数据，对其计算4字节的校验码，附加到最后，一共得到38字节的数据。
**目前，非压缩的格式几乎已经不使用了**。
> 使用非压缩格式的WIF是以5开头的字符串，使用压缩格式的WIF是以K或L开头的字符串，这个字符串就是需要私密保存的**私钥地址**。  

**推导公钥**  
上面说过，根据ECDSA算法，可以对一个256整数的私钥推导出两个256位整数（公钥），记作（x,y），它们是**非压缩的公钥**。由于ECC曲线特点，根据非压缩
的公钥（x,y）的x也可以推算出y，但需要知道y的奇偶性，所以最终（x,y）就可以记录为x'，它作为**压缩的公钥**。  
压缩格式的公钥实际上只保存x这一个256位整数，但需要根据y的奇偶性在x前面添加02或03前缀，y为偶数时添加02，否则添加03，这样，得到一个1+32=33字节
的压缩格式的公钥数据，记作x'。注意压缩格式的公钥和非压缩格式的公钥是可以互相转换的，但均不可反向推导出私钥。非压缩格式的公钥目前已很少使用，
原因是非压缩格式的公钥签名脚本数据会更长。  
**公钥哈希作为比特币钱包地址**  
要特别注意，比特币的地址并不是公钥，而是公钥的哈希。  
以压缩格式的公钥为例，从公钥计算地址的方法是，首先对1+32=33字节的公钥数据进行Hash160（即先计算SHA256，再计算RipeMD160），得到20字节的哈希。
然后，添加0x00前缀，得到1+20=21字节数据，再计算4字节校验码，拼在一起，总计得到1+20+4=25字节数据。对上述25字节数据进行Base58编码，得到总是
以1开头的字符串，该字符串即为比特币地址，可以安全地公开给任何人。
>注意：对非压缩格式的公钥和压缩格式的公钥进行哈希编码得到的地址，都是以1开头的，因此，从地址本身并无法区分出使用的是压缩格式还是非压缩格式的公钥。


## UTXO模型（Unspent Transaction Outputs）
它是比特币创新的一种账户余额模型（不同于常见系统中只记录某个账户的余额的方式），翻译为"未花费的交易输出"，下面进行解释。
#### 1. 每个区块中的每笔交易都由n(n≥0)个input和m（m≥1）个output（输入和输出）组成
首先，每个区块由区块头和区块体组成，区块头存放了比特币协议号、区块哈希、时间戳、上一区块哈希等字段信息；  
区块体则存放多笔交易信息，而每笔交易都由n(n≥0)个input和m（m≥1）个output（输入和输出）组成。  
- 输入（input）：0个或多个转账方比特币地址，以及转出比特币数量
- 输出（output）：1个或多个接受方比特币地址，每个地址对应一个转入比特币数量
- **每笔交易的输入之和 == 输出之和**

**请看下图**

<img src="./images/Transactions-input-and-output-in-blockchain.png" style="zoom: 80%">

#### 2.Coinbase
区块体中，第一笔交易叫做Coinbase（也可称铸币交易），它也是一笔特殊交易，因为其没有input（或者说以Coinbase为input），只有output就是矿工比特币地址以及得到的比特币奖励。  
每个区块都有Coinbase，这笔交易将使矿工比特币地址凭空增加比特币余额。
#### 3.UTXO交易过程
比如，我这个月打工挣了1w块，那么这笔交易的输入就是公司-1w，输出就是我+1w，这很简单；然后我要消费，比如买个电脑6k，剩余4k，在传统系统中，是我的
银行账户余额数字变成了4k，我后续的消费（交易）都是基于这个余额数字进行的，我也是通过银行账户直接查询我的余额，这很方便没问题；但是在比特币系统中，
没有类似银行账户的中央系统可查，那就说到这个UTXO模型，这个模型中，我上述2笔交易的记录是这样的：  
```
tx1： input：公司，1w，output：我，1w  （相当于我+1w）

tx2： input：我，1w  output-1：商场，6k （消费）
                    output-2:我，  4k （找零）
```
可以发现，现在我的余额可以这样计算：+1w - 1w + 4k = 4k，这其实就是关联我的多笔交易的输入输出合并后的结果。这里要注意一点，这个模型中不允许将
output拆开消费，比如tx1中针对我的output是1w，但我买电脑只需要6k，那我第二笔交易不可以只input 6k，必须从之前的交易中找到≥6k的output作为这次
交易的input，当然也可以合并多个之前的output作为这次的input（足够抵扣本次交易就行），简单说就是不能掰开花只能合并花。在tx2中可以看到，如果input
数字大于消费需要的output数字，那么抵扣消费后的数字会作为找零再形成兑付给我的output，这部分就叫做【**未花费的交易输出**】，等到这个output作为其他交易
的input之后，那它就不叫未花费的交易输出了！

**计算余额**  
在比特币网络中，每笔交易的每个输出都是一定数量的不可分割的比特币，这些输出由全网共同验证，并且可能被其持有者用做后续交易的输入。比特币全节点会
追踪和统计网络中所有可用的未交易输出，我们称这些交易输出为UTXO集合。当我们称一位用户拥有多少比特币时，实际上指的是比特币网络中有多少UTXO可以被该用户
控制的密钥使用。  
这些UTXO可能分散在成千上万的区块和交易中，比特币钱包帮我做收集和计算的工作，将这些UTXO总额以账户余额方式显示给用户。  
可以看到，UTXO模型完美适配比特币这种去中心化的货币系统。
>注意：交易输出可以是任意数量的Satoshi（比特币最小计量单位）；Coinbase只有输出，所以可以认为比特币网络是**先有输出**，再有输入的。

在任意时间点，现有 UTXO 的集合都被称为 UTXO 集。比特币节点会追踪 UTXO 集，从而确定哪些代币未被花费，以及哪些人可以花费它们。该系统可以让比特币
解决多重支付（Double Spend）问题。双重花费问题是长期困扰数字货币尝试的一大难题。

#### 4.UTXO 是如何创建的？  
新的 UTXO 是通过花费现有 UTXO 创建的。每个比特币交易都由输入和输出组成。输入花费已有 UTXO，输出则创建新的 UTXO。如果新的 UTXO 是通过销毁
已有 UTXO 创建的，那么最初的 UTXO 是怎么来的？  
显然就是Coinbase，每个UTXO的历史都可以追溯到 coinbase 交易的一个或多个输出。

#### 5.传统账户余额模型
这种模型更容易让人们理解，它就类似银行账户，银行系统直接存储了每个账户余额，交易时判断发起方余额是否足够。  
以太坊（Ethereum）就是使用账户余额模型的典型代表，它还区分了外部账户和智能合约账户，这里不做过多说明。

#### 6.UTXO与传统账户余额模型对比

1. 建模对象：用户交易是扣减分布在全网区块中与自己账户地址关联的未交易输出之和，也就是代币，所以UTXO对资产进行建模；余额模型对账户进行建模
2. 适用场景：UTXO不存在账户当前状态概念，可称它是无状态的，因此很难基于UTXO模型构建转账/货币发行等数字货币领域外的复杂应用，如智能合约；  
而余额模型就直接拥有账户余额状态等数据，可以进行丰富的编程应用。
3. 隐私性：UTXO模型为用户提供隐私优势。比特币用户可以将每个UTXO存储在不同的地址中分别处理。通过这种方式，用户可以隐藏其持有的 UTXO 之间的联系；
比特币的设计极大降低了生成新地址的难度。传统余额模型使得生成新账户变得非常麻烦，甚至不可行，迫使用户将全部或大部分资金存放在一个账户中。观察者可以
直接查询这个账户的交易流水以获得信息。

## 解决双花问题

这要提到几个关键词：**UTXO，区块时间戳，6次确认，分叉及最长链原则**

1. UTXO：当一个用户接收比特币时，金额被当作UTXO记录到区块链里。比特币系统当中记录着每一笔未花费的交易输出。当某一笔比特币交易被创建并广播到区块链网络之后，
接收到此交易信息的节点会对交易进行验证，需要去UTXO数据库里查，检查其是否存在于UTXO中。如果交易输出已不存在于UTXO中，则验证失败。
2. 区块时间戳：当一个用户同时将1个比特币同时转账给两人时，两笔交易仅会有一笔成功，因为矿工会选择记录优先接收到的，或者交付手续费更高的那笔交易。
当交易被矿工们先后记录到区块后，根据区块时间戳的大小来证明，最先被记录（时间戳小的）的交易才是有效的，其他记录了来自同一笔UTXO的交易的区块将被网络拒绝
（因为这一笔UTXO已经被全部花费了）。
3. 6次确认：是指在这当前区块之后又有5个区块被计算出来连接到区块链上，每一个都相当于对前面一个区块进行确认，区块链上每增加一个区块就增大了前面区块被篡改的难度，
6个之后就认为基本上没法被篡改，所以认为这笔交易就算完成了。
4. 分叉及最长链原则：因为同一时间段内全网不止一个节点能计算出随机数，也就是同时挖到了矿，这些节点都会把自己挖到的区块，链到自己本地的区块链上，
这就出现了区块链分叉，他们都会在网络广播他们各自打包好的区块，以便于其他节点同步完最新数据后，在最新的区块链上继续挖矿。由于同步需要时间，不同矿工看到的
这些区块是有先后顺序的，矿工会把先看到的区块复制过来，然后在该区块上继续开始新的挖矿工作。最终其中的一条链被证实为较长的一条，那么其他分支链条上工作
的节点将转换阵营，开始在较长的链条上工作，这条链就成了主链，其他分叉出来的链将会被网络抛弃、消失。

## 数字钱包

TODO