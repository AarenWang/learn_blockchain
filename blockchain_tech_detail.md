# 区块链技术细节（整理）

## 区块链分层参考模型

<img src="./images/blockchain_layer.jpg" style="zoom: 90%">

### 1. 网络层

区块链技术网络层本质上是一个P2P网络。以比特币为例，网络层涉及技术主要包括有构建网络、传播机制、同步机制、验证机制以及其他一些高级功能。

#### 1.1 构建网络

区块链网络层一般也是基于TCP/IP的，比特币网络使用的是8333端口，节点加入也是建立对应TCP链接。首先需要先找到一些稳定可靠的合法节点地址，
将自己版本内容等基本信息发送给网络上的节点，网络上的节点收到后，会检测是否兼容，之后回复确认信息建立连接。

#### 1.2 传播机制

网络层的功能主要是节点之间传播各类信息。一般是指向网络中主动发送信息，并依次转发在全网广播开来。这种信息一般主要是用户钱包新生成的交易信息，以及
矿工成功打包的区块信息。

#### 1.3 同步机制

指的是节点向邻居节点请求信息，用于同步各种数据。在比特币系统中，节点加入网络后，会向自己的邻居节点发送getaddr信息，请求自己的邻居节点将其维护的
节点地址列表同步给自己；除此之外，还会发送getblocks、getdata等请求来同步区块信息。

#### 1.4 验证机制

节点收到交易和区块信息后，对其合法性进行验证，只有合法正确的信息才会对其进行转发，如果不符合共识规则则丢弃。这样能保证全网中只传播合法信息，不至于
网络拥塞，同时防止DOS攻击。

#### 1.5 其他

在区块链技术发展过程中，不断加入了一些新功能和协议。例如，后来的比特币区块链中使用洋葱网络（Tor），原理是将用户发起的交易信息，先在网络中找到一些
节点转发，最后回到该用户自己，形成闭环，然后再从这个闭环内发送到全网，使得无法推断到底是哪个节点发起的这笔交易。

### 2. 数据层

区块链数据层就是嵌入式数据存储的一个分布式账本。除了账本外，节点一般会维护一些节点信息等元数据，属于区块链底层数据结构。目前包含的区块链数据层包含以下特征：

- 分布式账本：每个节点保存一份**完整**账本数据，存储于嵌入式数据库中；
- 区块结构：交易信息被打包成区块；
- 链式结构：所有区块通过哈希指针方式连接在一起，防止篡改；
- 节点信息：向邻居节点请求其维护的节点地址列表，这些返回值也会以文件形式存储在本地。

### 3. 安全层

主要是密码学中的技术，这层是区块链的安全保障。一般区块链中都涉及大量数字资产，所以区块链安全是现阶段比较重要，研究最广泛，成果最多的一个方向。
安全层提供的服务包括：

- 基础安全保证：在区块链的账户体系中，使用了椭圆曲线算法生成地址作为账户公开地址。另外，挖矿、地址生成、签名等多处使用了哈希算法。地址生成也用到了编解码算法；
- 隐私保护：比特币采用的是假名机制，由于账本是公开透明的，区块链不具备很好的隐私保护能力。目前区块链隐私保护的研究多集中在数字货币上，主要目标是将用户身份和交易
  以及交易金额做分离。现阶段可以被用于区块链隐私保护的技术主要有环签名技术、盲签名技术、零知识证明、同态加密以及新兴的安全多方计算。
- 网络安全：由于区块链网络的开放性，在设计区块链架构时，要重点考虑防止安全攻击的问题。常见攻击手段有：
    - DOS攻击：攻击者发送大量垃圾信息到某个节点或全网中，导致网络拥塞，造成DOS攻击；
    - 女巫攻击：攻击者搭建大量恶意节点，以此获得大量投票数；
    - 日蚀攻击：比特币单节点一般默认设置8个连接，攻击者可以设置8个恶意节点去连接至某个正常节点，导致其被隔离出比特币网络，这通常是针对交易所的攻击。
- 密钥安全：区块链之上的数字资产的拥有权完全绑定到单一秘钥，一旦丢失就无法找回。所以这是设计数字钱包时，需要重点考虑的问题。目前市场上的钱包一般分为
  硬件钱包、在线钱包等，它们在可用性和安全性方面有不同的考量。密钥安全涉及的技术，主要有分层确定性密钥管理、助记词、离线签名等。
- 算法安全：区块链设计过程中，也需要考虑所使用算法的安全性，必须使用那些目前被证明为极难被破解的算法。目前的区块链项目中多采用椭圆曲线算法、SHA-256等。

### 4. 共识层

这层的作用是让所有人按照一种机制对区块链的某一刻的状态达成一致性的认识，本质上是一个分布式系统中的一致性方案，用于解决拜占庭将军问题。区块链系统中
需要达成共识的内容主要包括三部分：交易、区块、以及一些其他共识内容。  
关于共识机制的研究成果已经有多种方案，如Paxos、Raft等；目前现有区块链项目中所采用的共识算法如下表所示：

| 项目                                              | 共识机制                           |
|-------------------------------------------------|--------------------------------|
| 比特币系列：以Bitcoin技术体系为基础发行<br/>的数字货币，如莱特币、达低币、大零币等 | PoW                            |
| 点点币                                             | PoS                            |
| 以太坊                                             | PoW结合PoS，未来会升级到纯PoS共识          |
| 超级账本                                            | Kafka算法，Solo排序；共识机制可插拔，支持拜占庭容错 |
| 比特股、Steem、EOS等                                  | DPoS                           |
| 瑞波                                              | 瑞波共识（Ripple）                   |

### 5. 合约层

主要包括各种脚本、代码、算法机制和智能合约，它是区块链技术可编程的基础保证。合约层的本质是将代码逻辑存储在区块链中，实现可以自行定义和编写的智能合约，
在触发某一条件时，无需第三方调用，代码自动执行，即常说的「代码即法律」，这也是区块链去信任的基础。  
智能合约一般使用高级语言编写后，编译成为可供区块链用户调用的ABI二进制接口文件，部署到区块链上。目前公有链的智能合约编程分为两类：

- 以太坊：使用的是Solidity语言，执行环境是EVM虚拟机；
- EOS：它选用的语言是功能更强大的C++，执行环境是WebAssembly。并且EOS考虑了可扩展性设计，将会支持安全的沙盒环境设计成可插拔模式，将来可支持各种
  沙盒，以允许其他平台的智能合约无缝迁移到此平台。

### 6.服务层

主要包括区块链中的数字货币发行机制和分配机制。比特币中引入挖矿奖励来激励节点加入去完成区块打包和验证工作；达氏币中加入网络成为混币节点需要抵押一部分
数字货币，如果作恶则不会返回；EOS为代表的基于DPoS共识建立的区块链系统中，为防止女巫攻击，使用代币作为抵押投票。在早期区块链体系中，被成为激励层。

### 7.应用层

主要包括各类场景下的实际应用，类似常用的PC客户端、手机客户端等。二者区别是，区块链中的应用叫做去中心化应用（DApp）。由于早期区块链主要应用场景就是
数字货币，所以当时主要应用层就是各类数字货币钱包。  
目前，受限于行业生产关系变革中遇到的阻力，区块链应用暂时还没有彻底普及开来。典型的应用，如以太坊上运行最多的就是众筹项目，EOS上运行最多的应用集中
在博彩业。

## 区块链现存问题

### 1. 数据冗余过量

在一个完全去中心化的区块链系统中，用户如果想要亲自验证交易合法性，同时保证数据的可信、完整、未篡改的特性，用户就需要下载全部的账本。
随着时间的推移，区块链的数据量呈线性递增，长期以往，极大提高了用户的使用成本，导致用户只能依赖其他全节点去验证交易，然而这会导致新的中心化趋势。

以比特币为例，每10min产生一个区块，每个区块1MB，每年的区块增长速度为24x60/10x365=51.3GB，10年后大概需要5TB。EOS理论上可以达到太字节（百万TB），
按照一个交易100字节计算，1天的区块数据为1000000x100x60x60x24=7.8TB，一年的区块数据量为7.8x265=2868TB，到2023年大约需要14340TB存储空间。
另外，还需要包括智能合约代码以及用户上传的图片、视频等。普通用户个人用户显然无法承担如此巨大的存储空间。

### 2. 系统安全

区块链本质上是一个分布式数据库。与传统应用系统不同，在运行过程中，区块链会将数据信息采用分布式方式记录，并且通过共识机制由所有参与者共同记录。
整个区块链平台具有开放性的特点，特别是公有链中，任意节点可以自由加入/退出区块链网络，任意节点都可以存储整个账本数据。区块链的这种开放性也决定了其不同于传统技术的安全问题。

### 3. 共识算法

就目前业界研究情况来看，并不存在一种完美的共识算法适用于任何场景，每一种共识算法均有自己的优缺点，适用于不同的应用场景，我们只能根据实际应用来取舍。
例如，在最早的区块链平台中，比特币和以太坊都采用PoW算法。PoW算法是目前唯一经过严格数学论证的安全共识机制，但其缺点也是明显，那就是速度慢且严重浪费资源。
BitShare和EOS等所采用的DPoS共识机制虽然提高了效率，并解决了资源浪费的问题，但是牺牲了去中心化的特性，存在21个超级节点，并且共识的安全严重依赖于代币。

由于目前设计完美的共识机制几乎不太可能实现，所以大多数项目在开发区块链平台时，均会考虑可插拔共识机制，用户在实际部署应用时，可以根据场景使用合适的共识机制。

下表展示了常见共识机制之间的特点对比：

| 共识机制     | 是否挖矿 | 需要代币 | 安全性 | 资源消耗 | 去中心化程度 | 交易确认时间 | 交易性能 | 典型项目          | 适用场景   |
|----------|------|------|-----|------|--------|--------|------|---------------|--------|
| ByteBall | 否    | 是    | 高   | 小    | 不完全    | 长      | 高    | ByteBall      | DAG区块链 |
| IOTA     | 否    | 是    | 高   | 小    | 完全     | 长      | 高    | IOTA          | DAG区块链 |
| Pool验证池  | 否    | 否    | 高   | 小    | 不完全    | 实时     | 高    | 私有链           | 私有链    |
| Ripple   | 否    | 是    | 高   | 小    | 不完全    | 实时     | 高    | Ripple网       | 公有链    |
| Paxos    | 否    | 否    | 高   | 小    | 不完全    | 实时     | 高    | 暂无            | 联盟链    |
| PBFT     | 否    | 否    | 高   | 小    | 不完全    | 实时     | 高    | 超级账本          | 联盟链    |
| DPoS     | 否    | 是    | 高   | 小    | 不完全    | 秒级     | 高    | BitShare、EOS等 | 公有链    |
| PoS      | 是    | 是    | 高   | 一般   | 完全     | 短      | 低    | 点点币、未来币等      | 公有链    |
| PoW      | 是    | 是    | 高   | 大    | 完全     | 长      | 低    | 比特币、莱特币等      | 公有链    |

### 4. 可扩展性

区块链的可扩展性问题主要包括两个方面：交易效率和区块链的分叉与升级。

#### 4.1 交易性能

我们已经知道，比特币区块链每秒只能处理大概7笔交易，每笔交易需要接近1h的确认时间。相较于比特币，以太坊的处理速度得到了不小的改善，每秒可以处理二十多笔交易，
每笔交易一般推荐15-20个区块的确认，大约时间为4-8分钟。而现有的传统系统中，像支付宝交易的处理峰值可达每秒几十万，如果投入正式环境，区块链现有的处理速度实在难以让人满意。

可扩展性是传统分布式系统的基本特性，但区块链由于去中心化的要求，难以满足可扩展性。业界总结了一个三元悖论描述去中心化与可扩展性之间的矛盾，
尚未被严格证明，只能被称为猜想，但实际系统设计过程中却能感觉到时时受其挑战：去中心化、安全性、可扩展性这三个属性，区块链系统无法同时满足，最多三选二。
这也叫做分布式不可能三角。

就目前来说，解决区块链交易性能的主要方案有以下几种：  
**【共识机制创新】**  
从PoW到PoS再到DPoS和各种BFT类算法，共识机制不断创新，区块链平台性能也不断得到提升。**但需要明确的是**，后来创新的这些共识机制，
并非各方面都优于开始PoW，而是在其他方面作出了妥协，以达到提高交易性能的目的。比如PoS虽然解决了资源浪费问题，但是却产生了高概率分叉以及弱去中心化问题；
而DPoS虽然性能高，但是该算法以代理人共识取代全网共识的做法也受到一部分人的抨击。

**【交易通道】**  
交易通道的思路是保持底层区块链协议不变，将交易放到链下进行，通过改变协议用法的方式来解决扩展性问题。链下部分可以采用传统中心化分布式系统实现，
闪电网络是典型方案的一种。

**【分片处理】**  
以太坊项目正在研发中的分片（sharding）方案的总体思路是每个节点只处理一部分交易，比如一部分账户发起的交易，从而减轻节点的计算和存储负担。

**【多链架构】**  
主要思路是将原本的一条链分成多条链，每条链都负责部分计算和存储业务，并且有可扩展性，即链的数量可以随着业务量和数据的增加而增加，系统的总体性能和存储空间也会随之提升。
**侧链**技术就是一种方案。

#### 4.2 链的分叉（fork）

区块链的分叉，尤其是硬分叉也是一个目前难以解决的问题。最典型的例子，就是The
DAO事件所造成的以太坊分叉为ETH和ETC两条链，虽然为用户挽回了智能合约安全问题造成的损失，
但是导致了很大一部分人对区块链去中心化的质疑，显然这是靠中心化的运作强行更改了系统的运行轨迹。再比如BTC与BCH的分叉、BCH与BSV的分叉，也都造成了社区的分裂，
这不仅是技术层面的分歧，更多的也是各方利益使然。

**【硬分叉】**  
硬分叉是指代码修改后，旧节点拒绝接收新节点创造的区块。不符合原规则的区块将被忽略。硬分叉将会导致一个正在运行的区块链系统在某个区块高度发生永久分叉，
分叉点后产生的区块互不关联。硬分叉是**不向前兼容**的。

**【软分叉】**  
软分叉是指旧节点不会意识到系统代码发生改变，并继续接收新节点创造的区块，所以软分叉是**向前兼容**的。

分叉通常是为了解决当前系统中的某些问题，比如提高交易性能，亦或回滚某些交易（The DAO事件）。比特币采用的隔离见证就是一种软分叉方案，
隔离见证的思路是在不改变区块结构及参数的前提下，将签名信息放在块外存储，从而间接对区块扩容，提高了一些交易效率。而BCH则认为隔离见证只是减缓了网络拥塞问题，
也没有显著提高交易效率，还使得系统结构变得复杂，不利于未来系统改造。所以比特币社区又产生出另一种方案，那就是直接修改区块参数，将区块大小1MB的限制改为4MB。
显然，这种修改不是向前兼容的，旧节点不会认可4MB的区块，从而导致BTC分叉出了BCH。

## 区块链安全问题

相对于传统单点中心化服务的模式，区块链去中心化的特性在安全层面上已经是一种非常大的进步。在传统信息安全领域中，安全包括三个基本要素，
分别是保密性、完整性、可用性。本节从这三个方面入手，分析区块链自身所带的安全特性。

### 1. 区块链安全属性

#### 1.1 保密性

保密性是指要求保护数据内容不被泄露给非授权的个人、实体或流程，强调有用信息只被授权对象使用的特征。常用保密手段如下：

- 物理保密：利用限制、隔离、掩蔽、控制等措施，保护信息不被泄露；
- 防窃听：使对手侦听不对有用信息；
- 防辐射：防止有用信息以各种途径辐射出去；
- 信息加密：在密钥的控制下，用加密算法对信息加密存储、传播。即使对手得到了加密后的信息，也会因为没有密钥无法读取内容。

在区块链技术中，列举下面几种使用加密技术的场景：

- 存储用户密钥场景中使用了加密技术（用户设置一个密码来保存私钥在本地）
- 交易场景中使用了非对称加密技术来实现了无泄密授权（对交易签名）；
- 门罗币使用环签名算法来实现隐匿交易双方地址。

#### 1.2 完整性

完整性是指用户、进程或者硬件组件具有验证所发送或传送的内容的准确性的能力，并且进程或硬件组件不会被任何方式改变。完整性的目的是通过阻止威胁或探测威胁，保护可能遭到不同方式危害数据的完整性和数据相关属性的完整性。

区块链对数据的完整性实现了很好的保护。其主要通过链式账本、哈希加密以及交易签名技术保护了整个账本数据的完整性。

#### 1.3 可用性

可用性通常是指在某个考察期内系统正常运行的效率。可用性受到系统错误、基础设施问题、恶意攻击和系统负载等因素影响，通常以正常运行时间的百分比来衡量。
同时，如何在合理的时间内响应用户的请求也是可用性的一个重要方面。

在区块链系统中，由于多个节点的存在、多个备份的账本，从正常运行时间百分比的角度来看，可用性是增强的。以比特币为例，从2009年1月比特币网络正式启动至今，
已经有十多年的光阴，这期间只出现了有限次的安全事件，几乎一直处于稳定运行状态。但同样是由于这种分布式多备份的特性，数据同步和共识机制的存在，
使得区块链在性能方面与传统中心化系统相比还有很大差距。从这一角度讲，区块链在可用性方面，相较于保密性和完整性，还有很大的改进空间。

### 2. 数据层安全

#### 2.1 数据存储安全

在传统信息安全中，数据存储安全的目标包含多个方面，如保护机密数据、确保数据完整性、防止数据破坏和丢失等。而这些工作都是由提供服务的中心化机构来完成。
对于区块链技术来说，其账本具有分布式存储且不可篡改的特性，所以区块链上的数据天然具有存储安全的特性，而保护机密数据则需要区块链隐私保护技术来实现，
这一点在后续章节进行说明。

在传统信息安全中，实现数据安全的方式有很多种，如访问控制、增加安全硬件防护等。而区块链是一种开放、去中心化的技术，数据安全完全依赖于密码学技术，
例如比特币中交易和区块实体都涉及非对称加密算法、数字签名和哈希技术等多种密码学组件。为满足更高的隐私保护需求，还要引入环签名、零知识证明、
多方安全计算等隐私保护技术。区块链本身开放式的技术特点也决定了其数据安全会面临与传统信息安全不同的风险。

综上所述，区块链数据层的安全主要包括两个方面，密码学算法本身的安全风险和区块链数据内容的安全风险。

**【一、密码算法安全风险】**  
信息安全理论中，密码算法安全分为信息论安全和计算安全。信息论安全是指无条件安全、绝对安全，但为了考虑实用性，我们所使用的密码均为计算安全，
即基于一个困难的数学假设，在现有计算能力下是解不开这个数学难题的。例如，现在区块链技术中常用到的椭圆曲线算法，就是基于离散对数问题，这种算法目前来看是安全的。
但是，从现代密码学发展历史来看，MD5/DES等早期常用算法均被证明了存在安全漏洞，以及SHA-1算法也在2005年2月被证明安全性不足，SHA-2和SHA-1类型，
虽然还未出现有效攻击，但安全性也被严重质疑。随着量子计算的飞速发展，现在被认为安全的算法，未来也未必是无懈可击。  
目前针对加密算法进行攻击的方式主要有穷举攻击、碰撞攻击、长度扩展攻击、后门攻击、量子攻击等。而量子计算对一般密码算法的影响如下表所示：

| 密码算法        | 类型   | 功能      | 安全性影响  |
|-------------|------|---------|--------|
| AES         | 对称密码 | 加密      | 攻击难度减半 |
| SHA-2,SHA-3 | 哈希算法 | 哈希      | 攻击难度减半 |
| RSA         | 公钥算法 | 加密      | 攻破     |
| ECDSA,ECDH  | 公钥算法 | 签名，密钥交换 | 攻破     |
| DSA         | 公钥算法 | 签名，密钥交换 | 攻破     |

**【二、链上内容安全风险】**  
由于区块链技术拥有不可篡改/删除的特性，给到了不法分子可利用之处。不法分子将大量有害信息、病毒特征码、淫秽信息等写入区块链中，影响区块链生态环境。
另一方面，大量垃圾交易数据攻击会阻塞区块链，使得正常交易和信息迟迟得不到处理。

#### 2.2 密钥存储安全

在目前的知名区块链应用中，不乏大量的加密货币应用，这其中涉及到数字资产交易，直接关系到用户利益，也成为攻击者的目标。即使现代密码学技术现阶段是安全的，
也是建立在密钥安全的基础上。然而现有区块链技术普遍缺乏有效的密钥管理技术。以比特币为例，每年因使用、存储不当导致的密钥丢失都会给用户带来巨大的利益损失。

目前，区块链技术中主流的密钥管理方法包括本地存储、离线存储、托管存储和门限钱包。

**【一、本地存储】**  
将密钥直接或加密存放在本地存储介质中，这种方法最不安全，很容易被恶意读取和使用，本地设备损坏时也无法恢复。

**【二、离线存储】**  
将密钥存储在不联网的离线设备中，完全与互联网隔离，如现在常见的硬件钱包，这种方案最大的问题是携带和使用不方便，而且有些离线存储方案在使用时仍需要接入互联网，
无法完全避免恶意软件的入侵。

**【三、托管存储】**  
可以使用第三方提供的托管服务管理密钥，但这显然违反了区块链去中心化的本意，密钥的安全与否完全取决于第三方机构的可信程度。

**【四、门限钱包】**  
使用门限加密技术将密钥分散处处在多个设备中，使用时需要多方参与，如常见的（t,n）门限密码算法，n个参与者中至少有t方参与才可恢复密钥，
允许最大t-1个被攻破。

### 3. 网络层安全

区块链中的网络节点，可能是云服务器，也可能是个人计算机，安全性必然参差不齐，对安全性较差的节点发起网络攻击，必然会造成严重的后果。
针对区块链分布式网络的安全风险，主要分为DDoS攻击、女巫攻击和日蚀攻击。

#### 3.1 DDoS攻击

由于目前区块链系统的处理能力有限，攻击者很容易向某个节点发送垃圾交易，通过较大流量致使该节点瘫痪。除此之外，攻击者也可以利用节点客户端的漏洞发起攻击，使其无法提供服务。
程度较轻的情况下，只攻击一个节点，使某个节点的用户无法使用区块链服务。程度严重的话，使网络中部分节点瘫痪，这就意味着全网的安全性直接降低，
例如在比特币网络，这意味着总体算力的下降，网络会更容易遭受51%攻击。而且，目前发起DDoS攻击的成本非常低，大量的攻击工具可以从黑市上轻易购买。

#### 3.2 女巫攻击

女巫攻击（Sybil Attack）是2002年提出的，它是作用于P2P网络中的一种攻击形式，攻击者控制**多个节点**
来伪造多个身份存在于P2P网络中，从而达到削弱网络的冗余性，
降低网络健壮性，监视或干扰网络正常活动等目的。

目前，对抗女巫攻击的手段主要是防止身份伪造。由于公链和联盟链的网络结构不同，抗女巫攻击的方式一般也分为两种。

**【一、公有链】**  
主要做法是设计共识机制时，不依赖于节点数量。常用共识机制PoW采用算力证明节点身份不是伪造的（算力提高伪造单个节点的伪造成本），算力大的具有主导权；
PoS采用代币也就是股权证明节点的身份不是伪造的，股权大的具有主导权；DPoS采用代币投票，而不是一机一票。

**【二、联盟链】**  
联盟链主要采用的共识机制都是一机一票形式的，如PBFT。联盟链一般是引入身份认证的机制，具体分两种，基于第三方的身份认证和纯分布式的身份认证。
二者区别在于，前者需要一个可信机构管理身份认证，而纯分布式身份认证则需要全网大多数节点认证才可以加入网络。

#### 3.3 日蚀攻击

日蚀攻击（Eclipse Attack）是指攻击者利用节点间的拓扑关系实现网络隔离的一种典型攻击方式。其基本思想是攻击者通过网络拓扑控制目标节点的数据传入传出节点，
限制目标节点与外界的数据交互，甚至将目标节点与区块链主网隔离，使目标节点仅能接收到攻击传输的消息，导致目标节点保存的区块链视图与主网视图不一致，
破坏局部的一致性。

日蚀攻击最早是一种针对比特币网络的攻击。每个比特币网络的节点最多可以允许117个网络节点接入（输入连接），同时默认向8个其他节点发起连接（输出连接）。日蚀攻击的目标就是建立足够多的节点，
让某个节点的输入连接和输出连接都是恶意节点，使得这个节点只可以和恶意节点通信，之后再发起攻击。这种攻击行为最常见的是攻击交易所的服务器。

除了比特币网络，也有研究人员在2018年1月9日向以太坊透露了它们的攻击方法，为此，以太坊开发者发布了一个补丁 Geth
v1.8.1来修复这个漏洞。

### 4. 共识层安全

共识机制是区块链中各分布式节点能够协同运作的核心，但是现在没有一种完美的共识机制可以适用所有应用场景。通常来说，一般都是根据区块链平台的应用环境、
网络拓扑选择适合的共识机制。每一种共识机制都有自己的漏洞，本节我们列出几种常见的对共识算法的攻击手段。

#### 4.1 51%攻击

51%攻击主要针对PoW算法。PoW中如果攻击者掌握了全网51%的算力，那么就可以很轻易的从某个历史区块开始，生成一条高度大于现有主链的新链，这样就达到了篡改账本的目的。
虽然达到全网51%的算力是一件非常困难的事，但也并非不可能，如2019年1月份，以太经典（ETC）就受到了51%攻击。

#### 4.2 币龄累积攻击

这种攻击手段针对的是PoS算法。在PoS算法中，币龄条件也作为记账权的竞争资格之一，攻击者可以通过长期囤积代币的方式来轻易提高获得记账权的概率，
再通过组建大量节点获得记账权就能控制整个区块链网络的**共识**。

#### 4.3 自私挖矿

自私挖矿的概念最早在2014年提出。正常状态下，矿工挖到某个区块就立刻进行全网广播获取奖励，而在自私挖矿中，矿工维护了两条链，一条公开的，一条私有的，
具体操作流程如下：

1. 自私矿池挖到块A之后不直接发布全网，只在自己的矿池中广播该快，形成私有链，并且继续挖下一块B；
2. 当检测到网络上有人发出下一块A'时，再广播自己挖到的块A，使网络进入竞争状态（A与A'是相同高度区块）；
3. 再当自私矿池挖出B时，就直接发布，由于B是跟在A后面的，所以A-B这条链会大概率成为最长链，进而使得自私矿池可以获得块A和块B的收益，导致网络中其他节点在A'以及其分叉链上的挖矿行为无效；
4. 倘若其他诚实节点在A后挖出新块，自私矿池也可以享受A的收益；
5. 还有一种情况是其他诚实节点更快的挖到了A'之后的区块，那么自私矿池就没有任何收益。

这通常需要自私矿池在全网中拥有占比较高的算力，才能达到一定的收益率。

#### 4.4 贿赂攻击

贿赂攻击更多的针对节点个数有限的联盟链，一般是指恶意攻击者通过数字货币或法币贿赂共识节点，使其与自己共同工作在特定区块或分叉上，
来生成有利于攻击方的分叉链。以PBFT算法为例，可以容忍f个节点发生错误（全网至少有3f+1个节点），因此，只需贿赂f+1个节点就可以使共识停止，
贿赂2f+1个节点就能转变共识方向。

### 5. 应用层安全

一个面向用户的DApp应用都会有Web或者移动端App/传统Web App中所遇到的安全问题。在这里我们引用OWASP（Open Web Application
Security Project），
介绍一下其整理的10项最严重的Web App安全风险。

#### 5.1 注入

例如SQL注入、NoSQL注入、OS注入和LDAP注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。

#### 5.2 失效的身份认证

通常，通过错误使用App的身份认证和会话管理功能，攻击者能够破译密码、密钥或会话Token，或者利用其他开发缺陷来暂时性或永久性冒充其他用户身份。

#### 5.3 敏感数据泄露

许多Web App和API都无法正确保护敏感数据，如财务、医疗等用户隐私数据。攻击者可以窃取这些未加密的数据来实施电信诈骗、身份冒充或其他犯罪行为。
因此，我们需要对敏感数据加密，这包括后台数据库、网络通信传输以及浏览器渲染中的数据。

#### 5.4 XML外部实体（XXE）

许多较早的或配置错误的XML处理器评估了XML文件中的外部实体引用。攻击者可以利用外部实体窃取使用URI文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施DOS攻击。

#### 5.5 失效的访问控制

未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据。如访问其他用户账户、查看敏感文件、修改其他用户数据、更改访问权限等。

#### 5.6 安全配置错误

这是最常见的一种问题，通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的HTTP头配置以及包含敏感信息的详细错误信息所造成的。
因此，不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。

#### 5.7 跨站脚本（XSS）

当App的新网页中包含不受信任的、未经验证或转义的前端代码时，或者使用可以创建HTML或JS的浏览器API更新现有网页时，就会出现XSS缺陷。
XSS让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。

#### 5.8 不安全的反序列化

它也会导致远程代码执行。攻击者可以利用这种方式来执行包括重播攻击、注入攻击和特权升级攻击。

#### 5.9 使用含有已知漏洞的组件

组件（如库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。

#### 5.10 不足的日志记录和监控

不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，
系统缺陷被检测出的时间超过200天，且通常是通过外部检测方得知，不是通过内部流程或监控检测得知。

### 6. 隐私保护

#### 6.1 比特币匿名性分析

比特币白皮书中简单描述了隐私保护方面的内容，大概内容是比特币的交易除了记录交易所必须的双方转账地址以及金额外，不会包含任何有关用户身份的数据。
更进一步，用户还可以在每次交易中都使用一个新的密钥对来隐匿账户的交易轨迹。

但是经过大量关于隐私和社交网络的研究之后，人们发现即使隐藏多重假名后，也会被串联起来，显露隐私信息，所以比特币并没有完全达到隐私保护的目的。
有研究人员对比特币账本的交易记录进行分析，根据交易之间的关系，从账本抽象总结出三种图状结构，交易图、地址图和组织机构图。如下图

<img src="./images/bitcoin_tx_trail.jpg" height="306" width="930">

图中a表示比特币地址，之后所有关于比特币隐私分析的结论都是在这个基础上进行的。

**【一、交易图】**  
交易图是最直观和简单的一种抽象。除了Coinbase交易外，比特币中一笔交易的输入一定是来源于上一笔交易的输出。如上图中的（a）所示推导，
最后可以表示为一种有向无环图结构*G(T, L)*，其中*T*代表整个账本的交易集合，*L*代表交易输入和输入指向的联系集合。

**【二、地址图】**  
由于每笔交易都是公开的，所以可以获取到每笔转账交易的来源地址和目的地址。对大量的交易地址转账方向分析之后，最终得到这个地址图，
从图中可以发现，有的是从一个地址转向多个地址，有的是从多个地址转向一个地址。

**【三、组织机构图】**  
比特币交易的特点，有一点是将多个未花费的输出组合气力啊，作为输入形成一笔交易。那么，这笔交易中的这些输入有极大可能性是来自同一组织机构之手。

将地址和身份对应起来还需要一些其他的方法。例如，一些地址是来自WikiLeaks和Silk Road公开的。也有一些在线服务、存储或交易所之类的，在使用前要求用户认证身份的。
还有一些是在公开的社交网络上通过爬虫获取，如bitcointalk等，这些工作都已经有研究人员完成。BitIodine则提供一种自动化的分析架构，使用上述方法论分析出交易图、
地址图、机构图，并归类，然后将用户和地址对应起来。

#### 6.2 隐私保护的常见做法

**【一、环签名技术】**  
假设一组用户，每个用户都有公钥和私钥对（pk1,sk1），（pk2，sk3）...（pk3，sk3）。以用户i为例，给定消息m计算一个环签名s，输入参数为（m,
sk<sub>i</sub>, pk<sub>1</sub>, sk<sub>1</sub>...pk<sub>n</sub>, sk<sub>n</sub>）。
谁都可以使用公开信息去验证签名的合法性，如果签名是正确的，那么就可以通过验证。而对于验证人来说，只知道签名的人在这一组公钥集合中，而不知道是具体哪一个。

**【二、零知识证明】**  
零知识证明（ZKP）的概念初见于1985年的论文《互动证明系统的知识复杂性》。ZKP系统是一种密码学技术，允许两方（证明方和验证方）来证明某个提议是真实的，
而且无须泄露它是真实之外的任何信息。举个简单的例子，在机场领取丢失的行李箱时，你只需证明你知道行李箱的密码就能取走行李箱，这个时候你不需要说出行李箱密码，
而是说出其中的一两件物品特征然后再打开行李箱由工作人员检查即可。像这种无需泄露信息本身（如密码）而证明一个论述的过程就叫做零知识证明。

目前，零知识证明用于区块链隐私的三种主要落地方案有Zk-SNARKs、Zk-STARKs和BulletProofs（防弹证明）。

**【三、同态加密】**  
维基百科：同态加密（Homomorphic encryption）是一种加密形式，它允许人们对密文进行特定形式的代数运算得到仍然是加密的结果，将其解密所得到的结果与对明文进行同样的运算结果一样。
换言之，这项技术令人们可以在加密的数据中进行诸如检索、比较等操作，得出正确的结果，而在整个处理过程中无需对数据进行解密。其意义在于，真正从根本上解决将数据及其操作委托给第三方时的保密问题，例如对于各种云计算的应用。

**【四、安全多方计算】**  
安全多方计算（SMPC）主要用于解决一组互不信任的参与方，在保护各自隐私的前提下，希望共同计算出一个函数并得到各自的输出，在这个过程中，除了应得到的输出之外，参与方不会得到任何额外信息。

具体来说，假设以P<sub>1</sub>，P<sub>2</sub>，...P<sub>n</sub>代表多个参与者，各参与者希望共同安全地计算某个给定的具有n个输入和n个输出的函数：
F(x<sub>1</sub>, x<sub>2</sub>, ...x<sub>n</sub>)=(y<sub>1</sub>, y<sub>2</sub>, ...y<sub>n</sub>)，其中，函数F的n个输入分别由各方秘密提供，
在计算结束后，各方分别得到输出y<sub>1</sub>, y<sub>2</sub>, ...y<sub>n</sub>，在这个过程中，每个参与者P<sub>i</sub>
除了知道x<sub>i</sub>, y<sub>i</sub>外，并不了解其他任何信息。

## 智能合约安全检测

### 1. 智能合约概述

#### 1.1 智能合约基本介绍

智能合约是在区块链上运行的程序，合约代码和状态存储在链中，它们可以发送和接收资金。今天，数以百万的智能合约在各个公链上运行，而且这一数字正在增长，
同时也埋下了越来越多的安全隐患。智能合约涉及的安全问题与传统代码不同，首先是它部署之后无法更新（也就无法升级或打补丁）；其次，它们是在一个新的运行时环境生态系统中编写的，
相对难以测试；第三，智能合约通常会直接涉及资金的操作，一旦被攻击者利用，会直接造成严重的经济损失。  
从2014年开始，层出不穷的智能合约安全漏洞事件造成了严重的资金损失，因此编写安全的智能合约极为重要。本章以以太坊上的智能合约漏洞为例，分析安全与不安全的智能合约代码，
总结编写安全的智能合约应遵守的规范及流程。

#### 1.2 智能合约漏洞分析

本章把以太坊智能合约漏洞发生的原因分为是哪个层面：Solidity层面、EVM层面和区块链层面。如下表所示，所列出的漏洞都有对应真实案例，这些漏洞造成了巨额的资金损失。

| 漏洞发生层面   | 漏洞描述                        |
|----------|-----------------------------|
| Solidity | 重入攻击、访问控制、整数溢出、未检查返回值、拒绝服务  |
| EVM      | 变量使用类型限制、合约Gas成本限制、调用堆栈深度限制 |
| 区块链底层    | 可被操控值依赖、私有变量依赖、阻塞交易攻击       |

**【一、Solidity层面】**  
这一层发生的漏洞主要是因为代码编写的逻辑问题或是使用了不当的Solidity内置方法，简而言之，它们基本都和Solidity的语言特性有关。例如

- 重入攻击，是由于外部函数对合约的send()或者call.value()方法进行了递归调用造成的漏洞，解决办法是改为使用transfer()，该方法只能被调用一次。需要注意的是合约中应避免使用send()或者call.value()方法，以免受到重入攻击；
- 访问控制攻击：是由于合约未设置函数的访问权限而造成的漏洞，解决办法是为函数加一个onlyOwner修饰符，限制函数访问；
- 整数溢出：是由于在这个语言中，要计算的数如果超过了EVM能处理的数字范围（0\~2<sup>256</sup>-1）就会重新从0或2<sup>256</sup>-1开始计数，解决办法是智能合约中只要是数学计算都使用safe-Math库；
- 未检查返回值：是由于合约使用了send()或call.value()函数，却没有检查函数是否执行成功就进行下一步操作导致的漏洞，解决办法是校验成功后再下一步；
- 拒绝服务：是由于攻击者恶意回退函数执行失败，使得原合约无法进行下一步操作而造成的漏洞，解决办法是把主动退款改为让用户申请退款，这样一个用户退款失败不影响合约继续执行。
这里需注意的是智能合约中能写成pull形式（用户主动发起调用）的代码不要写成push形式（合约主动执行操作）的代码；

**【二、EVM层面】**  
这一层发生的漏洞主要是由于EVM的限制导致的。 例如
- 变量使用类型限制：是因为var关键字声明变量时默认变量的类型是uint8，如果使用了for(var i=0;i<x;i++)这样的用法且恰好x>255，那将导致无限循环直到gas耗尽。
所以在编写合约时应显式标注变量类型，避免使用var；
- Gas限制：是由于在合约被调用时，每次修改合约状态都需要使用gas，如果一个函数涉及特别复杂的操作，需要消耗的gas达到了交易或区块的gas限制，那么对这个函数的调用将会在消耗很多gas的同时调用失败，
并回滚合约状态；
- 调用堆栈深度限制：是由于EVM最大允许栈深度为1024，如果调用者嵌套调用时，深度到1024，将会调用失败。

攻击者可以利用EVM的这三个限制使得合约调用失败，以此阻止合约下一步操作。避免这类漏洞的方法就是在编写合约中的函数时，避免让合约的下一步操作依赖这一步的状态。

**【三、区块链层面】**  
这一层主要有如下漏洞。  
**私有变量依赖**  
在Solidity中，私有变量虽然无法被自身合约以外的外围直接读取，但只要某一条交易中使用了这个私有变量，它就化私为公了。因为在以太坊中交易信息是全网公开的，
且每个交易的数据字段对应了规定的内容，只要对数据字段进行分析就可以知道私有变量的值。  

**被操控值依赖**  
智能合约中可被人为操控的值有随机数的种子、交易顺序、合约余额等。
- 随机数种子。在某类游戏合约中，通常需要依赖一个随机数下注来判断输赢。而计算机世界中不存在一个绝对随机数，只能通过seed去生成一个相对随机数，但如果这个seed是可预测的，那随机数也就不随机了。
智能合约中的随机数一般使用未来的区块头属性作为种子，如区块Hash、区块高度、时间戳、难度值等，而这些区块头属性的值都是可被矿工认为控制的，所以不能依赖这些属性作为随机数种子。
解决办法是使用链外可信第三方服务来获取随机数，如Oraclize。
- 交易顺序，也是可被矿工操作的。
- 合约中的Ether余额，这个值也特别容易诱导开发人员将其当做确定值来作为判断条件。尤其是Solidity新手可能会认为合约只能通过带有payable修饰符的函数接受Ether，
事实上，除此之外还有两种方式可将Ether强制发给合约，一种是通过selfdestruct自毁合约，可在删除合约地址中所有字节码的同时将合约存储的Ether强制发送到指定地址，
若这个地址是一个合约地址，那么这些Ether将不会调用这个合约的任何方法而是直接存入合约中。另一种更神奇的方式是让这个合约在出生前就拥有一笔财富，因为合约地址都是确定的，
可根据这个合约的创建人地址以及交易的nonce值计算得到，这样就可在创建这个合约之前就给它转入一笔Ether，当合约创建后就拥有非零Ether余额。  
合约逻辑应该避免依赖于合约余额的确切值，因为可能飞来横币。如果非要使用合约余额作为判断条件，也应根据实时查询到的合约当前余额来判断。

**阻塞交易攻击**  
以太坊智能合约中存在一个指令assert()用于断言，当assert参数不满足条件时，不仅交易失败，而且会消耗交易设置的gasLimit对应的gas费用，而花费gas越多的交易越容易被区块打包。
但每个区块总的gas数目也是有上限的，因此单笔交易使用的gas越多，区块包含的交易数就越少。在游戏合约中，就可以利用这个特点来破坏游戏公平，
假如某个游戏设定大奖的获得者是每轮游戏结束前最后一个购买道具的玩家，那么玩家们会在倒计时快要结束时，发起购买交易参与游戏，如果能幸运地在最后一刻被矿工打包，即可获胜。
如果恰好这个时候玩家能够调用游戏提供的函数查询倒计时以及最后一位玩家的购买地址，那么玩家就可以在查询得知刚好自己是最后一位时发送一条交易费很高的交易并通过assert()使gas被全部消耗，
吸引矿工优先打包并占满区块的gas，从而使得其他玩家的交易无法被正常打包，最终加速游戏结束，极大地提高了自己的中奖概率。  
所有采用类似机制，即需要玩家抢在某个时间范围内完成某种竞争操作的智能合约，都会受此种威胁。防范此类攻击只能通过完善游戏规则，如禁止玩家查看游戏具体进程的信息，
这样玩家就不知道当前最后一个参与者是谁。或者把最后一个参与者获奖改为只有一定的概率获奖，增加玩家的试错成本。

#### 1.3 智能合约检测现状
目前全球做智能合约安全审计的公司并不多，开发出形式化验证工具的更是少之又少，国内外做合约形式化验证的平台有俄罗斯的SmartDec、瑞士的Securify、
美国的Quantstamp和中国的Vaas，其中VaaS检测平台比较易用。除此之外，非基于形式化验证的工具有Solidity开发文档中推荐的SmartCheck、Oyente、Manticore、Mythril、Porosity等，
这些工具只能检测特定的部分漏洞。再者就是依靠专业智能合约审计人员人工检测，检测结果依赖审计人员水平而定。

#### 1.4 智能合约检测方法
大致有以下几种方法。
1. 把已知的可能存在漏洞的代码写在工具的源代码中，当待检测的合约代码有类似漏洞代码或逻辑时，便将其标记出来，这一类检测工具有SmarkCheck、Securify等。
2. 对合约代码进行反编译，然后通过对字节码的分析，找出漏洞，这一类检测工具有Oyente、Manticore、Mythril、Porosity等。
3. 通过生成一个DOT图，显示合约代码的功能控制流程，实现对代码逻辑的检测，这列工具主要有Solgraph。

还有一类检测方法与上述工具的检测思路都不一致，它就是形式化验证，这是形式化方法中的一部分。形式化方法就是用数学工具来进行定义、开发和验证一个系统。  
形式化验证是一种基于数学和逻辑学的方法，其应用于智能合约的过程简单来说就是在智能合约部署之前，对其代码和文档进行形式化建模，然后通过数学的手段对代码安全性和功能正确性进行严格证明，
可有效检测出智能合约是否存在安全漏洞和逻辑漏洞。下图展示了形式化验证应用于智能合约的过程

<img src="./images/smart_contract_xingshihuayanz.jpg" width="580" height="388" >

形式化验证方法可用于智能合约的建模、模型检测和验证过程，以支持规模化的智能合约生成。通过形式化验证，开发者可以直接发现代码中的逻辑漏洞和安全漏洞，或者自动生成安全的合约代码，
大大降低代码中漏洞存在的可能性，也弥补了人工方式对逻辑漏洞查找的不足。

### 2. 安全代码编写建议
#### 2.1 代码模块化
如果要编写逻辑复杂的合约，尽可能使合约代码模块化，使得一个模块只包含一个特定的功能。模块化不仅方便代码编写者对代码整体逻辑的把我，而且一旦代码发生错误，
也方便测试者定位代码的错误所在。

#### 2.2 使用安全代码
如果代码中需要使用的功能，已被安全审计智能合约框架所包含，直接调用已被审计过的代码比自己重写这个功能更安全。例如，在以太坊中发行ERC-20 代币的代码，
在开源框openZeppelin中已有经过大量安全测试的代码模板，使用此代码模板发行代币可避免很多安全风险。

#### 2.3 防范代码漏洞
针对上一节中描述的合约漏洞，需要在编码时加以防范，此处不再赘述。

#### 2.4 做好漏洞措施
无论使用何种检测方法/工具，漏洞都是无法完全避免的，这时就需要代码能在错误发生时自己暂停，以防继续被攻击，并能允许进行合约升级，一边合约继续使用。
此功能可使用assert()断言来实现，当断言条件不满足时（如本应为恒定值的代币总量发生变化），将触发断言失败，然后暂停合约执行。  
合约执行的方法有两种：
1. 虽然合约部署后不可更改，但可以利用一个专门的注册合约，在注册合约中保存最新版本的合约地址；
2. 另外一种就是更常见的方法。利用一个中间合约来转发调用数据到最新版本的合约。

防范可能发生的资金风险也可通过**限制转账速率**和**限制最大转账额度**来实现。这样当发生盗币危险时，可控制损失金额和给修复合约错误预留一定时间。

#### 2.5 合约测试
当合约代码编写完之后，发布之前还需要对合约进行大量测试。测试代码可以利用Truffle的测试框架来编写。Truffle是建立以太坊DApp的一套开发框架，
它提供了编译、部署、测试和创建合约所需的命令行工具，同时还提供了编写测试代码的包。利用它可以使用两种方法编写测试代码，一是使用JS编写，另一种是使用Solidity编写。
这两种方法对合约的执行方式有所不同。**执行方法不同**，在JS中被测试的合约所在客户端中执行，在Solidity中被测试的合约是通过被其他合约调用来执行。
使用JS编写测试代码时还可以使用Mocha测试框架和Chai断言库；Solidity测试可以与JS测试代码协同工作，编写完成后在命令行中使用`truffle test`命令运行它们。

在运行测试代码时，可现在以太坊轻节点Ganache中运行，以节省运行时间。但在生产环境中部署合约时，需要再次在Geth客户端或另外的以太坊客户端中运行测试。

智能合约编程和传统编程在资金安全方面有很多不同，首先是智能合约本身可以存储大量资金，一旦遭到攻击会直接导致资金损失，很容易被黑客当做攻击目标；
其次，智能合约代码是公开的，黑客可以不受限制地研究代码漏洞，只要代码存在漏洞，不被发现的概率很小，所以编写智能合约时需要尽可能详尽地考虑安全问题。
另外，由于智能合约在区块链上部署成功后就不能修改，即使发现了安全漏洞，也无法像传统程序那样打补丁或升级，所以合约编写者需要做到的是，一方面必须在编写代码过程中就把异常终止和升级逻辑写进智能合约，
另一方面必须减少编写不安全代码的概率。

参考：

- [《区块链技术开发指南-马兆丰》](https://baike.baidu.com/item/区块链技术开发指南/56688853?fr=aladdin)
